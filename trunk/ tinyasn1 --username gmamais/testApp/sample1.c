
/*
Code automatically generated by asn1cc tool
*/
#include <string.h>
#include "sample1.h"

void MyTestPDU_Initialize(MyTestPDU* pVal)
{

    pVal->kind = MyTestPDU_NONE;
}


flag MyTestPDU_IsConstraintValid(MyTestPDU* pVal, int* pErrCode)
{
    switch(pVal->kind)
    {
    case int1_PRESENT:
        if ( !(((pVal->u.int1>=0) && (pVal->u.int1<=15))) ) {
            *pErrCode = ERR_MyTestPDU_int1;
            return FALSE;
        }
        break;
    case int2_PRESENT:
        if ( !(((pVal->u.int2>=0) && (pVal->u.int2<=65535))) ) {
            *pErrCode = ERR_MyTestPDU_int2;
            return FALSE;
        }
        break;
    case enm_PRESENT:
        break;
    case buf_PRESENT:
        if ( !((pVal->u.buf.nCount == 10)) ) {
            *pErrCode = ERR_MyTestPDU_buf;
            return FALSE;
        }
        break;
    case gg_PRESENT:
        if ( !(((pVal->u.gg.int1>=0) && (pVal->u.gg.int1<=15))) ) {
            *pErrCode = ERR_MyTestPDU_gg_int1;
            return FALSE;
        }

        if ( !(((pVal->u.gg.int2>=0) && (pVal->u.gg.int2<=65535))) ) {
            *pErrCode = ERR_MyTestPDU_gg_int2;
            return FALSE;
        }


        if ( !((pVal->u.gg.buf.nCount == 10)) ) {
            *pErrCode = ERR_MyTestPDU_gg_buf;
            return FALSE;
        }

        break;
    default:
        *pErrCode = ERR_MyTestPDU;
        return FALSE;
    }
    return TRUE;
}

flag MyTestPDU_Encode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !MyTestPDU_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(pVal->kind)
    {
    case int1_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->u.int1, 0, 15);
        break;
    case int2_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->u.int2, 0, 65535);
        break;
    case enm_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
        switch(pVal->u.enm)
        {
        case MyTestPDU_enm_one:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
            break;
        case MyTestPDU_enm_two:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
            break;
        case MyTestPDU_enm_three:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
            break;
        case MyTestPDU_enm_four:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
            break;
        case MyTestPDU_enm_thousand:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
            break;
        }
        break;
    case buf_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
        /* No need to encode length (it is fixed size (10)*/
        for(i1=0;i1<pVal->u.buf.nCount;i1++)
        {
            BitStream_AppendByte0(pBitStrm, pVal->u.buf.arr[i1]);
        }
        break;
    case gg_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);

        /*Encode int1 (INTEGER)*/
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->u.gg.int1, 0, 15);

        /*Encode int2 (INTEGER)*/
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->u.gg.int2, 0, 65535);

        /*Encode enm (ENUMERATED)*/
        switch(pVal->u.gg.enm)
        {
        case gg_enm_one:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
            break;
        case gg_enm_two:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
            break;
        case gg_enm_three:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
            break;
        case gg_enm_four:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
            break;
        case gg_enm_thousand:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
            break;
        }

        /*Encode buf (OCTET STRING)*/
        /* No need to encode length (it is fixed size (10)*/
        for(i1=0;i1<pVal->u.gg.buf.nCount;i1++)
        {
            BitStream_AppendByte0(pBitStrm, pVal->u.gg.buf.arr[i1]);
        }

        break;
    }
    return TRUE;
}

flag MyTestPDU_Decode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nChoiceIndex = 0;
    asn1SccSint enumIndex = 0;
    asn1SccSint nCount = 0;
    int i1 = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 4)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(nChoiceIndex)
    {
    case 0:
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->u.int1, 0, 15)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        pVal->kind = int1_PRESENT;
        break;
    case 1:
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->u.int2, 0, 65535)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        pVal->kind = int2_PRESENT;
        break;
    case 2:
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        switch(enumIndex)
        {
        case 0:
            pVal->u.enm = MyTestPDU_enm_one;
            break;
        case 1:
            pVal->u.enm = MyTestPDU_enm_two;
            break;
        case 2:
            pVal->u.enm = MyTestPDU_enm_three;
            break;
        case 3:
            pVal->u.enm = MyTestPDU_enm_four;
            break;
        case 4:
            pVal->u.enm = MyTestPDU_enm_thousand;
            break;
        }
        pVal->kind = enm_PRESENT;
        break;
    case 3:
        pVal->u.buf.nCount = 10;
        for(i1=0;i1<pVal->u.buf.nCount;i1++)
        {
            if ( !BitStream_ReadByte(pBitStrm, &pVal->u.buf.arr[i1]) ) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        pVal->kind = buf_PRESENT;
        break;
    case 4:
                /*Decode int1 (INTEGER)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->u.gg.int1, 0, 15)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        /*Decode int2 (INTEGER)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->u.gg.int2, 0, 65535)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        /*Decode enm (ENUMERATED)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        switch(enumIndex)
        {
        case 0:
            pVal->u.gg.enm = gg_enm_one;
            break;
        case 1:
            pVal->u.gg.enm = gg_enm_two;
            break;
        case 2:
            pVal->u.gg.enm = gg_enm_three;
            break;
        case 3:
            pVal->u.gg.enm = gg_enm_four;
            break;
        case 4:
            pVal->u.gg.enm = gg_enm_thousand;
            break;
        }
        /*Decode buf (OCTET STRING)*/
        pVal->u.gg.buf.nCount = 10;
        for(i1=0;i1<pVal->u.gg.buf.nCount;i1++)
        {
            if ( !BitStream_ReadByte(pBitStrm, &pVal->u.gg.buf.arr[i1]) ) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        pVal->kind = gg_PRESENT;
        break;
    }
    return TRUE;
}


MyTestPDU testPDU = {
    .kind = int1_PRESENT,
    .u = { .int1=10
} };
