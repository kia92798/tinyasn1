
/*
Code automatically generated by asn1cc tool
*/
#include <string.h>
#include "sample1.h"

void asn1MYBOOL_Initialize(asn1MYBOOL* pVal)
{

    *pVal = FALSE;
}


flag asn1MYBOOL_IsConstraintValid(asn1MYBOOL* pVal, int* pErrCode)
{
    return TRUE;
}

flag asn1MYBOOL_Encode(asn1MYBOOL* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1MYBOOL_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_AppendBit(pBitStrm, *pVal);
    return TRUE;
}

flag asn1MYBOOL_Decode(asn1MYBOOL* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_ReadBit(pBitStrm, pVal)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_INTEGER_Initialize(asn1T_INTEGER* pVal)
{

    *pVal = 0;
}


flag asn1T_INTEGER_IsConstraintValid(asn1T_INTEGER* pVal, int* pErrCode)
{
    if ( !(((*pVal>=-1000) && (*pVal<=1000))) ) {
        *pErrCode = ERR_asn1T_INTEGER;
        return FALSE;
    }
    return TRUE;
}

flag asn1T_INTEGER_Encode(asn1T_INTEGER* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_INTEGER_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -1000, 1000);
    return TRUE;
}

flag asn1T_INTEGER_Decode(asn1T_INTEGER* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -1000, 1000)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_REAL_Initialize(asn1T_REAL* pVal)
{

    *pVal = 0;
}


flag asn1T_REAL_IsConstraintValid(asn1T_REAL* pVal, int* pErrCode)
{
    if ( !(((*pVal>=-10000) && (*pVal<=10000))) ) {
        *pErrCode = ERR_asn1T_REAL;
        return FALSE;
    }
    return TRUE;
}

flag asn1T_REAL_Encode(asn1T_REAL* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_REAL_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeReal(pBitStrm, *pVal);
    return TRUE;
}

flag asn1T_REAL_Decode(asn1T_REAL* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeReal(pBitStrm, pVal)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_ACCELERATION_Initialize(asn1T_ACCELERATION* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_ACCELERATION_IsConstraintValid(asn1T_ACCELERATION* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_ACCELERATION;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_ACCELERATION_Encode(asn1T_ACCELERATION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_ACCELERATION_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_ACCELERATION_Decode(asn1T_ACCELERATION* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_ACS_CMD_Initialize(asn1T_ACS_CMD* pVal)
{

    pVal->set_acs1_cmd = FALSE;
    pVal->set_acs2_cmd = FALSE;
}


flag asn1T_ACS_CMD_IsConstraintValid(asn1T_ACS_CMD* pVal, int* pErrCode)
{


    return TRUE;
}

flag asn1T_ACS_CMD_Encode(asn1T_ACS_CMD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_ACS_CMD_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode set-acs1-cmd (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_acs1_cmd);

    /*Encode set-acs2-cmd (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_acs2_cmd);

    return TRUE;
}

flag asn1T_ACS_CMD_Decode(asn1T_ACS_CMD* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode set-acs1-cmd (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_acs1_cmd)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-acs2-cmd (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_acs2_cmd)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_ANGLE_Initialize(asn1T_ANGLE* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_ANGLE_IsConstraintValid(asn1T_ANGLE* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_ANGLE_Encode(asn1T_ANGLE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_ANGLE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_ANGLE_Decode(asn1T_ANGLE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_ANGULAR_RATE_Initialize(asn1T_ANGULAR_RATE* pVal)
{

    asn1T_INTEGER_Initialize(&pVal->p_rate);
    asn1T_INTEGER_Initialize(&pVal->q_rate);
    asn1T_INTEGER_Initialize(&pVal->r_rate);
}


flag asn1T_ANGULAR_RATE_IsConstraintValid(asn1T_ANGULAR_RATE* pVal, int* pErrCode)
{
    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->p_rate, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->q_rate, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->r_rate, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_ANGULAR_RATE_Encode(asn1T_ANGULAR_RATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_ANGULAR_RATE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode p-rate (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->p_rate, pBitStrm, pErrCode, FALSE);

    /*Encode q-rate (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->q_rate, pBitStrm, pErrCode, FALSE);

    /*Encode r-rate (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->r_rate, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_ANGULAR_RATE_Decode(asn1T_ANGULAR_RATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode p-rate (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->p_rate, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-rate (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->q_rate, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode r-rate (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->r_rate, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CM_TELEMETRY_Initialize(asn1T_CM_TELEMETRY* pVal)
{

    int i1 = 0;

    pVal->cm_statuses.nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        pVal->cm_statuses.arr[i1] = FALSE;
    }
    asn1T_INTEGER_Initialize(&pVal->acm_status);
    asn1T_INTEGER_Initialize(&pVal->tgm_status);
    asn1T_INTEGER_Initialize(&pVal->mcm_phase);
    asn1T_INTEGER_Initialize(&pVal->obm_mode);
    pVal->alarm_counters.nCount = 0;
    for(i1=0;i1<2;i1++)
    {
        asn1T_INTEGER_Initialize(&pVal->alarm_counters.arr[i1]);
    }
    pVal->internal_rates.nCount = 0;
    for(i1=0;i1<6;i1++)
    {
        asn1T_INTEGER_Initialize(&pVal->internal_rates.arr[i1]);
    }
    asn1T_REAL_Initialize(&pVal->radial_velocity);
    asn1T_REAL_Initialize(&pVal->longitudinal_velocity);
}


flag asn1T_CM_TELEMETRY_IsConstraintValid(asn1T_CM_TELEMETRY* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->cm_statuses.nCount == 4)) ) {
        *pErrCode = ERR_asn1T_CM_TELEMETRY_cm_statuses;
        return FALSE;
    }

    for(i1=0;i1<pVal->cm_statuses.nCount;i1++)
    {
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->acm_status, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->tgm_status, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->mcm_phase, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->obm_mode, pErrCode) )
    {
        return FALSE;
    }

    if ( !((pVal->alarm_counters.nCount == 2)) ) {
        *pErrCode = ERR_asn1T_CM_TELEMETRY_alarm_counters;
        return FALSE;
    }

    for(i1=0;i1<pVal->alarm_counters.nCount;i1++)
    {
        if ( !asn1T_INTEGER_IsConstraintValid(&pVal->alarm_counters.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->internal_rates.nCount == 6)) ) {
        *pErrCode = ERR_asn1T_CM_TELEMETRY_internal_rates;
        return FALSE;
    }

    for(i1=0;i1<pVal->internal_rates.nCount;i1++)
    {
        if ( !asn1T_INTEGER_IsConstraintValid(&pVal->internal_rates.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->radial_velocity, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->longitudinal_velocity, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CM_TELEMETRY_Encode(asn1T_CM_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_CM_TELEMETRY_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode cm-statuses (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->cm_statuses.nCount;i1++)
    {
        /*Encode childlen : (BOOLEAN)*/
        BitStream_AppendBit(pBitStrm, pVal->cm_statuses.arr[i1]);
    }

    /*Encode acm-status (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->acm_status, pBitStrm, pErrCode, FALSE);

    /*Encode tgm-status (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->tgm_status, pBitStrm, pErrCode, FALSE);

    /*Encode mcm-phase (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->mcm_phase, pBitStrm, pErrCode, FALSE);

    /*Encode obm-mode (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->obm_mode, pBitStrm, pErrCode, FALSE);

    /*Encode alarm-counters (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (2)*/
    for(i1=0;i1<pVal->alarm_counters.nCount;i1++)
    {
        /*Encode childlen : (T-INTEGER)*/
        asn1T_INTEGER_Encode(&pVal->alarm_counters.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode internal-rates (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (6)*/
    for(i1=0;i1<pVal->internal_rates.nCount;i1++)
    {
        /*Encode childlen : (T-INTEGER)*/
        asn1T_INTEGER_Encode(&pVal->internal_rates.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode radial-velocity (T-REAL)*/
    asn1T_REAL_Encode(&pVal->radial_velocity, pBitStrm, pErrCode, FALSE);

    /*Encode longitudinal-velocity (T-REAL)*/
    asn1T_REAL_Encode(&pVal->longitudinal_velocity, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CM_TELEMETRY_Decode(asn1T_CM_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

        /*Decode cm-statuses (SEQUENCE OF)*/
    pVal->cm_statuses.nCount = 4;
    for(i1=0;i1<pVal->cm_statuses.nCount;i1++)
    {
        /*Decode childlen : (BOOLEAN)*/
        if (!BitStream_ReadBit(pBitStrm, &pVal->cm_statuses.arr[i1])) { 
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode acm-status (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->acm_status, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tgm-status (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->tgm_status, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode mcm-phase (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->mcm_phase, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode obm-mode (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->obm_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode alarm-counters (SEQUENCE OF)*/
    pVal->alarm_counters.nCount = 2;
    for(i1=0;i1<pVal->alarm_counters.nCount;i1++)
    {
        /*Decode childlen : (T-INTEGER)*/
        if ( !asn1T_INTEGER_Decode(&pVal->alarm_counters.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode internal-rates (SEQUENCE OF)*/
    pVal->internal_rates.nCount = 6;
    for(i1=0;i1<pVal->internal_rates.nCount;i1++)
    {
        /*Decode childlen : (T-INTEGER)*/
        if ( !asn1T_INTEGER_Decode(&pVal->internal_rates.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode radial-velocity (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->radial_velocity, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode longitudinal-velocity (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->longitudinal_velocity, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONFIGURATION_TABLE_Initialize(asn1T_CONFIGURATION_TABLE* pVal)
{

    pVal->pde1_pde4_config_is_selected = FALSE;
    pVal->pde1_is_available = FALSE;
    pVal->pde2_is_available = FALSE;
    pVal->pde3_is_available = FALSE;
    pVal->pde4_is_available = FALSE;
    pVal->dpu_reset_is_requested = FALSE;
    asn1T_INTEGER_Initialize(&pVal->cam_duration);
    pVal->cam_boost_only_is_requested = FALSE;
    pVal->halt_mode_is_requested = FALSE;
}


flag asn1T_CONFIGURATION_TABLE_IsConstraintValid(asn1T_CONFIGURATION_TABLE* pVal, int* pErrCode)
{






    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->cam_duration, pErrCode) )
    {
        return FALSE;
    }



    return TRUE;
}

flag asn1T_CONFIGURATION_TABLE_Encode(asn1T_CONFIGURATION_TABLE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONFIGURATION_TABLE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pde1-pde4-config-is-selected (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde1_pde4_config_is_selected);

    /*Encode pde1-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde1_is_available);

    /*Encode pde2-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde2_is_available);

    /*Encode pde3-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde3_is_available);

    /*Encode pde4-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde4_is_available);

    /*Encode dpu-reset-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->dpu_reset_is_requested);

    /*Encode cam-duration (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->cam_duration, pBitStrm, pErrCode, FALSE);

    /*Encode cam-boost-only-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->cam_boost_only_is_requested);

    /*Encode halt-mode-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->halt_mode_is_requested);

    return TRUE;
}

flag asn1T_CONFIGURATION_TABLE_Decode(asn1T_CONFIGURATION_TABLE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pde1-pde4-config-is-selected (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde1_pde4_config_is_selected)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde1-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde1_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde2-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde2_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde3-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde3_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde4-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde4_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode dpu-reset-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->dpu_reset_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cam-duration (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->cam_duration, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cam-boost-only-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->cam_boost_only_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode halt-mode-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->halt_mode_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROLLER_SATURATION_LEVEL_Initialize(asn1T_CONTROLLER_SATURATION_LEVEL* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_CONTROLLER_SATURATION_LEVEL_IsConstraintValid(asn1T_CONTROLLER_SATURATION_LEVEL* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CONTROLLER_SATURATION_LEVEL;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_CONTROLLER_SATURATION_LEVEL_Encode(asn1T_CONTROLLER_SATURATION_LEVEL* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_CONTROLLER_SATURATION_LEVEL_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_CONTROLLER_SATURATION_LEVEL_Decode(asn1T_CONTROLLER_SATURATION_LEVEL* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_CONTROL_GAINS_Initialize(asn1T_CONTROL_GAINS* pVal)
{

    asn1T_REAL_Initialize(&pVal->k1);
    asn1T_REAL_Initialize(&pVal->k2);
}


flag asn1T_CONTROL_GAINS_IsConstraintValid(asn1T_CONTROL_GAINS* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(&pVal->k1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->k2, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROL_GAINS_Encode(asn1T_CONTROL_GAINS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROL_GAINS_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode k1 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->k1, pBitStrm, pErrCode, FALSE);

    /*Encode k2 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->k2, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROL_GAINS_Decode(asn1T_CONTROL_GAINS* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode k1 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->k1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode k2 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->k2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CURRENT_Initialize(asn1T_CURRENT* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_CURRENT_IsConstraintValid(asn1T_CURRENT* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_CURRENT_Encode(asn1T_CURRENT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CURRENT_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_CURRENT_Decode(asn1T_CURRENT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_DTG_ANGULAR_INCREMENT_Initialize(asn1T_DTG_ANGULAR_INCREMENT* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_DTG_ANGULAR_INCREMENT_IsConstraintValid(asn1T_DTG_ANGULAR_INCREMENT* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_DTG_ANGULAR_INCREMENT;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_DTG_ANGULAR_INCREMENT_Encode(asn1T_DTG_ANGULAR_INCREMENT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_DTG_ANGULAR_INCREMENT_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_DTG_ANGULAR_INCREMENT_Decode(asn1T_DTG_ANGULAR_INCREMENT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_DTG_LSB_Initialize(asn1T_DTG_LSB* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_DTG_LSB_IsConstraintValid(asn1T_DTG_LSB* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_DTG_LSB;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_DTG_LSB_Encode(asn1T_DTG_LSB* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_DTG_LSB_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_DTG_LSB_Decode(asn1T_DTG_LSB* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_DTG_MEAS_TABLE_LINE_Initialize(asn1T_DTG_MEAS_TABLE_LINE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<30;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_DTG_MEAS_TABLE_LINE_IsConstraintValid(asn1T_DTG_MEAS_TABLE_LINE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 30)) ) {
        *pErrCode = ERR_asn1T_DTG_MEAS_TABLE_LINE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_DTG_MEAS_TABLE_LINE_Encode(asn1T_DTG_MEAS_TABLE_LINE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_DTG_MEAS_TABLE_LINE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (30)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_DTG_MEAS_TABLE_LINE_Decode(asn1T_DTG_MEAS_TABLE_LINE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 30;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_DTG_MEAS_TABLE_Initialize(asn1T_DTG_MEAS_TABLE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_DTG_MEAS_TABLE_LINE_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_DTG_MEAS_TABLE_IsConstraintValid(asn1T_DTG_MEAS_TABLE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_DTG_MEAS_TABLE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_DTG_MEAS_TABLE_LINE_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_DTG_MEAS_TABLE_Encode(asn1T_DTG_MEAS_TABLE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_DTG_MEAS_TABLE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-DTG-MEAS-TABLE-LINE)*/
        asn1T_DTG_MEAS_TABLE_LINE_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_DTG_MEAS_TABLE_Decode(asn1T_DTG_MEAS_TABLE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-DTG-MEAS-TABLE-LINE)*/
        if ( !asn1T_DTG_MEAS_TABLE_LINE_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_EFFICIENCY_MATRIX_LINE_Initialize(asn1T_EFFICIENCY_MATRIX_LINE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_EFFICIENCY_MATRIX_LINE_IsConstraintValid(asn1T_EFFICIENCY_MATRIX_LINE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_EFFICIENCY_MATRIX_LINE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_EFFICIENCY_MATRIX_LINE_Encode(asn1T_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_EFFICIENCY_MATRIX_LINE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_EFFICIENCY_MATRIX_LINE_Decode(asn1T_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_EFFICIENCY_MATRIX_Initialize(asn1T_EFFICIENCY_MATRIX* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_EFFICIENCY_MATRIX_LINE_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_EFFICIENCY_MATRIX_IsConstraintValid(asn1T_EFFICIENCY_MATRIX* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_EFFICIENCY_MATRIX;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_EFFICIENCY_MATRIX_LINE_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_EFFICIENCY_MATRIX_Encode(asn1T_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_EFFICIENCY_MATRIX_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-EFFICIENCY-MATRIX-LINE)*/
        asn1T_EFFICIENCY_MATRIX_LINE_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_EFFICIENCY_MATRIX_Decode(asn1T_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-EFFICIENCY-MATRIX-LINE)*/
        if ( !asn1T_EFFICIENCY_MATRIX_LINE_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_FCV_OPENING_DUR_CMD_Initialize(asn1T_FCV_OPENING_DUR_CMD* pVal)
{

    asn1T_INTEGER_Initialize(&pVal->fcv1_opening_duration);
    asn1T_INTEGER_Initialize(&pVal->fcv2_opening_duration);
}


flag asn1T_FCV_OPENING_DUR_CMD_IsConstraintValid(asn1T_FCV_OPENING_DUR_CMD* pVal, int* pErrCode)
{
    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->fcv1_opening_duration, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->fcv2_opening_duration, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_FCV_OPENING_DUR_CMD_Encode(asn1T_FCV_OPENING_DUR_CMD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_FCV_OPENING_DUR_CMD_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode fcv1-opening-duration (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->fcv1_opening_duration, pBitStrm, pErrCode, FALSE);

    /*Encode fcv2-opening-duration (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->fcv2_opening_duration, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_FCV_OPENING_DUR_CMD_Decode(asn1T_FCV_OPENING_DUR_CMD* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode fcv1-opening-duration (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->fcv1_opening_duration, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode fcv2-opening-duration (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->fcv2_opening_duration, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_FORCE_EFFICIENCY_MATRIX_LINE_Initialize(asn1T_FORCE_EFFICIENCY_MATRIX_LINE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_FORCE_EFFICIENCY_MATRIX_LINE_IsConstraintValid(asn1T_FORCE_EFFICIENCY_MATRIX_LINE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_FORCE_EFFICIENCY_MATRIX_LINE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_FORCE_EFFICIENCY_MATRIX_LINE_Encode(asn1T_FORCE_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_FORCE_EFFICIENCY_MATRIX_LINE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_FORCE_EFFICIENCY_MATRIX_LINE_Decode(asn1T_FORCE_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_FORCE_EFFICIENCY_MATRIX_Initialize(asn1T_FORCE_EFFICIENCY_MATRIX* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_FORCE_EFFICIENCY_MATRIX_LINE_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_FORCE_EFFICIENCY_MATRIX_IsConstraintValid(asn1T_FORCE_EFFICIENCY_MATRIX* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_FORCE_EFFICIENCY_MATRIX;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_FORCE_EFFICIENCY_MATRIX_LINE_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_FORCE_EFFICIENCY_MATRIX_Encode(asn1T_FORCE_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_FORCE_EFFICIENCY_MATRIX_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-FORCE-EFFICIENCY-MATRIX-LINE)*/
        asn1T_FORCE_EFFICIENCY_MATRIX_LINE_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_FORCE_EFFICIENCY_MATRIX_Decode(asn1T_FORCE_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-FORCE-EFFICIENCY-MATRIX-LINE)*/
        if ( !asn1T_FORCE_EFFICIENCY_MATRIX_LINE_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_FTCP_HEALTH_STATUS_Initialize(asn1T_FTCP_HEALTH_STATUS* pVal)
{

    pVal->ftc1_health_status_is_on = FALSE;
    pVal->ftc2_health_status_is_on = FALSE;
    pVal->ftc3_health_status_is_on = FALSE;
}


flag asn1T_FTCP_HEALTH_STATUS_IsConstraintValid(asn1T_FTCP_HEALTH_STATUS* pVal, int* pErrCode)
{



    return TRUE;
}

flag asn1T_FTCP_HEALTH_STATUS_Encode(asn1T_FTCP_HEALTH_STATUS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_FTCP_HEALTH_STATUS_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode ftc1-health-status-is-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->ftc1_health_status_is_on);

    /*Encode ftc2-health-status-is-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->ftc2_health_status_is_on);

    /*Encode ftc3-health-status-is-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->ftc3_health_status_is_on);

    return TRUE;
}

flag asn1T_FTCP_HEALTH_STATUS_Decode(asn1T_FTCP_HEALTH_STATUS* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode ftc1-health-status-is-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->ftc1_health_status_is_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode ftc2-health-status-is-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->ftc2_health_status_is_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode ftc3-health-status-is-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->ftc3_health_status_is_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_INERTIA_Initialize(asn1T_INERTIA* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_INERTIA_IsConstraintValid(asn1T_INERTIA* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_INERTIA;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_INERTIA_Encode(asn1T_INERTIA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_INERTIA_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_INERTIA_Decode(asn1T_INERTIA* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_Initialize(asn1T_INITIAL_EFFICIENCY_MATRIX_LINE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_IsConstraintValid(asn1T_INITIAL_EFFICIENCY_MATRIX_LINE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_INITIAL_EFFICIENCY_MATRIX_LINE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_Encode(asn1T_INITIAL_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_Decode(asn1T_INITIAL_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_INITIAL_EFFICIENCY_MATRIX_Initialize(asn1T_INITIAL_EFFICIENCY_MATRIX* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<6;i1++)
    {
        asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_INITIAL_EFFICIENCY_MATRIX_IsConstraintValid(asn1T_INITIAL_EFFICIENCY_MATRIX* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 6)) ) {
        *pErrCode = ERR_asn1T_INITIAL_EFFICIENCY_MATRIX;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_INITIAL_EFFICIENCY_MATRIX_Encode(asn1T_INITIAL_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_INITIAL_EFFICIENCY_MATRIX_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (6)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-INITIAL-EFFICIENCY-MATRIX-LINE)*/
        asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_INITIAL_EFFICIENCY_MATRIX_Decode(asn1T_INITIAL_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 6;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-INITIAL-EFFICIENCY-MATRIX-LINE)*/
        if ( !asn1T_INITIAL_EFFICIENCY_MATRIX_LINE_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_MASS_Initialize(asn1T_MASS* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_MASS_IsConstraintValid(asn1T_MASS* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_MASS_Encode(asn1T_MASS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_MASS_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_MASS_Decode(asn1T_MASS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_MATRIX_3_4_LINE_Initialize(asn1T_MATRIX_3_4_LINE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_MATRIX_3_4_LINE_IsConstraintValid(asn1T_MATRIX_3_4_LINE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_MATRIX_3_4_LINE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_MATRIX_3_4_LINE_Encode(asn1T_MATRIX_3_4_LINE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_MATRIX_3_4_LINE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_MATRIX_3_4_LINE_Decode(asn1T_MATRIX_3_4_LINE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_MATRIX_3_4_Initialize(asn1T_MATRIX_3_4* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_MATRIX_3_4_LINE_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_MATRIX_3_4_IsConstraintValid(asn1T_MATRIX_3_4* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_MATRIX_3_4;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_MATRIX_3_4_LINE_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_MATRIX_3_4_Encode(asn1T_MATRIX_3_4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_MATRIX_3_4_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-MATRIX-3-4-LINE)*/
        asn1T_MATRIX_3_4_LINE_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_MATRIX_3_4_Decode(asn1T_MATRIX_3_4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-MATRIX-3-4-LINE)*/
        if ( !asn1T_MATRIX_3_4_LINE_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_MSU_ID_Initialize(asn1T_MSU_ID* pVal)
{

    asn1T_INTEGER_Initialize(pVal);
}


flag asn1T_MSU_ID_IsConstraintValid(asn1T_MSU_ID* pVal, int* pErrCode)
{
    if ( !asn1T_INTEGER_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_MSU_ID_Encode(asn1T_MSU_ID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_MSU_ID_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_INTEGER_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_MSU_ID_Decode(asn1T_MSU_ID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_INTEGER_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_MSU_STATUS_Initialize(asn1T_MSU_STATUS* pVal)
{

    *pVal = slave;
}


flag asn1T_MSU_STATUS_IsConstraintValid(asn1T_MSU_STATUS* pVal, int* pErrCode)
{
    return TRUE;
}

flag asn1T_MSU_STATUS_Encode(asn1T_MSU_STATUS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_MSU_STATUS_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(*pVal)
    {
    case slave:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
        break;
    case master:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
        break;
    }
    return TRUE;
}

flag asn1T_MSU_STATUS_Decode(asn1T_MSU_STATUS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint enumIndex = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        *pVal = slave;
        break;
    case 1:
        *pVal = master;
        break;
    }
    return TRUE;
}


void asn1T_OBUT_Initialize(asn1T_OBUT* pVal)
{

    asn1T_INTEGER_Initialize(pVal);
}


flag asn1T_OBUT_IsConstraintValid(asn1T_OBUT* pVal, int* pErrCode)
{
    if ( !asn1T_INTEGER_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_OBUT_Encode(asn1T_OBUT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_OBUT_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_INTEGER_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_OBUT_Decode(asn1T_OBUT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_INTEGER_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_ON_OFF_CMD_Initialize(asn1T_ON_OFF_CMD* pVal)
{

    pVal->on_cmd = FALSE;
    pVal->off_cmd = FALSE;
}


flag asn1T_ON_OFF_CMD_IsConstraintValid(asn1T_ON_OFF_CMD* pVal, int* pErrCode)
{


    return TRUE;
}

flag asn1T_ON_OFF_CMD_Encode(asn1T_ON_OFF_CMD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_ON_OFF_CMD_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode on-cmd (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->on_cmd);

    /*Encode off-cmd (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->off_cmd);

    return TRUE;
}

flag asn1T_ON_OFF_CMD_Decode(asn1T_ON_OFF_CMD* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode on-cmd (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->on_cmd)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode off-cmd (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->off_cmd)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_ACM_DATA_Initialize(asn1T_PFS_ACM_DATA* pVal)
{

    pVal->data_is_available = FALSE;
    asn1T_INTEGER_Initialize(&pVal->x_velocity);
    asn1T_INTEGER_Initialize(&pVal->y_velocity);
}


flag asn1T_PFS_ACM_DATA_IsConstraintValid(asn1T_PFS_ACM_DATA* pVal, int* pErrCode)
{

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->x_velocity, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->y_velocity, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_ACM_DATA_Encode(asn1T_PFS_ACM_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_ACM_DATA_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode data-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->data_is_available);

    /*Encode x-velocity (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->x_velocity, pBitStrm, pErrCode, FALSE);

    /*Encode y-velocity (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->y_velocity, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_ACM_DATA_Decode(asn1T_PFS_ACM_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode data-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->data_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode x-velocity (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->x_velocity, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode y-velocity (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->y_velocity, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EWC_MSU_PDE_T_Initialize(asn1T_PFS_EWC_MSU_PDE_T* pVal)
{

    asn1T_ACS_CMD_Initialize(&pVal->pfs_ewc_msu_pde1_t);
    asn1T_ACS_CMD_Initialize(&pVal->pfs_ewc_msu_pde2_t);
    asn1T_ACS_CMD_Initialize(&pVal->pfs_ewc_msu_pde3_t);
    asn1T_ACS_CMD_Initialize(&pVal->pfs_ewc_msu_pde4_t);
}


flag asn1T_PFS_EWC_MSU_PDE_T_IsConstraintValid(asn1T_PFS_EWC_MSU_PDE_T* pVal, int* pErrCode)
{
    if ( !asn1T_ACS_CMD_IsConstraintValid(&pVal->pfs_ewc_msu_pde1_t, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ACS_CMD_IsConstraintValid(&pVal->pfs_ewc_msu_pde2_t, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ACS_CMD_IsConstraintValid(&pVal->pfs_ewc_msu_pde3_t, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ACS_CMD_IsConstraintValid(&pVal->pfs_ewc_msu_pde4_t, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_EWC_MSU_PDE_T_Encode(asn1T_PFS_EWC_MSU_PDE_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWC_MSU_PDE_T_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-ewc-msu-pde1-t (T-ACS-CMD)*/
    asn1T_ACS_CMD_Encode(&pVal->pfs_ewc_msu_pde1_t, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewc-msu-pde2-t (T-ACS-CMD)*/
    asn1T_ACS_CMD_Encode(&pVal->pfs_ewc_msu_pde2_t, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewc-msu-pde3-t (T-ACS-CMD)*/
    asn1T_ACS_CMD_Encode(&pVal->pfs_ewc_msu_pde3_t, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewc-msu-pde4-t (T-ACS-CMD)*/
    asn1T_ACS_CMD_Encode(&pVal->pfs_ewc_msu_pde4_t, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_EWC_MSU_PDE_T_Decode(asn1T_PFS_EWC_MSU_PDE_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-ewc-msu-pde1-t (T-ACS-CMD)*/
    if ( !asn1T_ACS_CMD_Decode(&pVal->pfs_ewc_msu_pde1_t, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewc-msu-pde2-t (T-ACS-CMD)*/
    if ( !asn1T_ACS_CMD_Decode(&pVal->pfs_ewc_msu_pde2_t, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewc-msu-pde3-t (T-ACS-CMD)*/
    if ( !asn1T_ACS_CMD_Decode(&pVal->pfs_ewc_msu_pde3_t, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewc-msu-pde4-t (T-ACS-CMD)*/
    if ( !asn1T_ACS_CMD_Decode(&pVal->pfs_ewc_msu_pde4_t, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EWM_DTG_MSU_MODE_Initialize(asn1T_PFS_EWM_DTG_MSU_MODE* pVal)
{

    *pVal = dtg_fine_mode;
}


flag asn1T_PFS_EWM_DTG_MSU_MODE_IsConstraintValid(asn1T_PFS_EWM_DTG_MSU_MODE* pVal, int* pErrCode)
{
    return TRUE;
}

flag asn1T_PFS_EWM_DTG_MSU_MODE_Encode(asn1T_PFS_EWM_DTG_MSU_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWM_DTG_MSU_MODE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(*pVal)
    {
    case dtg_fine_mode:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
        break;
    case dtg_coarse_mode:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
        break;
    }
    return TRUE;
}

flag asn1T_PFS_EWM_DTG_MSU_MODE_Decode(asn1T_PFS_EWM_DTG_MSU_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint enumIndex = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        *pVal = dtg_fine_mode;
        break;
    case 1:
        *pVal = dtg_coarse_mode;
        break;
    }
    return TRUE;
}


void asn1T_PFS_EWM_MSU_MSU_HS_Initialize(asn1T_PFS_EWM_MSU_MSU_HS* pVal)
{

    pVal->pfs_ewm_msu_hs_is_ok1 = FALSE;
    pVal->pfs_ewm_msu_hs_is_ok2 = FALSE;
    pVal->pfs_ewm_msu_hs_is_ok3 = FALSE;
}


flag asn1T_PFS_EWM_MSU_MSU_HS_IsConstraintValid(asn1T_PFS_EWM_MSU_MSU_HS* pVal, int* pErrCode)
{



    return TRUE;
}

flag asn1T_PFS_EWM_MSU_MSU_HS_Encode(asn1T_PFS_EWM_MSU_MSU_HS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWM_MSU_MSU_HS_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-ewm-msu-hs-is-ok1 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_ewm_msu_hs_is_ok1);

    /*Encode pfs-ewm-msu-hs-is-ok2 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_ewm_msu_hs_is_ok2);

    /*Encode pfs-ewm-msu-hs-is-ok3 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_ewm_msu_hs_is_ok3);

    return TRUE;
}

flag asn1T_PFS_EWM_MSU_MSU_HS_Decode(asn1T_PFS_EWM_MSU_MSU_HS* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-ewm-msu-hs-is-ok1 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_ewm_msu_hs_is_ok1)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-msu-hs-is-ok2 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_ewm_msu_hs_is_ok2)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-msu-hs-is-ok3 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_ewm_msu_hs_is_ok3)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EWM_SSU_MSU_MEAS_Initialize(asn1T_PFS_EWM_SSU_MSU_MEAS* pVal)
{

    asn1T_REAL_Initialize(&pVal->pfs_ewm_ssu_msu_meas1);
    asn1T_REAL_Initialize(&pVal->pfs_ewm_ssu_msu_meas2);
    asn1T_REAL_Initialize(&pVal->pfs_ewm_ssu_msu_meas3);
    asn1T_REAL_Initialize(&pVal->pfs_ewm_ssu_msu_meas4);
}


flag asn1T_PFS_EWM_SSU_MSU_MEAS_IsConstraintValid(asn1T_PFS_EWM_SSU_MSU_MEAS* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(&pVal->pfs_ewm_ssu_msu_meas1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->pfs_ewm_ssu_msu_meas2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->pfs_ewm_ssu_msu_meas3, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->pfs_ewm_ssu_msu_meas4, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_EWM_SSU_MSU_MEAS_Encode(asn1T_PFS_EWM_SSU_MSU_MEAS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWM_SSU_MSU_MEAS_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-ewm-ssu-msu-meas1 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->pfs_ewm_ssu_msu_meas1, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-ssu-msu-meas2 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->pfs_ewm_ssu_msu_meas2, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-ssu-msu-meas3 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->pfs_ewm_ssu_msu_meas3, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-ssu-msu-meas4 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->pfs_ewm_ssu_msu_meas4, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_EWM_SSU_MSU_MEAS_Decode(asn1T_PFS_EWM_SSU_MSU_MEAS* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-ewm-ssu-msu-meas1 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->pfs_ewm_ssu_msu_meas1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-ssu-msu-meas2 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->pfs_ewm_ssu_msu_meas2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-ssu-msu-meas3 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->pfs_ewm_ssu_msu_meas3, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-ssu-msu-meas4 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->pfs_ewm_ssu_msu_meas4, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_TGM_DATA_Initialize(asn1T_PFS_TGM_DATA* pVal)
{

    pVal->data_is_available = FALSE;
    asn1T_INTEGER_Initialize(&pVal->current_mode);
    pVal->target_data_valid = FALSE;
    pVal->on_line_bit_result = FALSE;
    asn1T_INTEGER_Initialize(&pVal->frame_counter);
    pVal->retro1_data_valid = FALSE;
    pVal->retro2_data_valid = FALSE;
    asn1T_INTEGER_Initialize(&pVal->target_range);
    asn1T_INTEGER_Initialize(&pVal->target_datation);
    asn1T_INTEGER_Initialize(&pVal->retro1_range);
    asn1T_INTEGER_Initialize(&pVal->retro1_datation);
    asn1T_INTEGER_Initialize(&pVal->retro2_range);
    asn1T_INTEGER_Initialize(&pVal->retro2_datation);
}


flag asn1T_PFS_TGM_DATA_IsConstraintValid(asn1T_PFS_TGM_DATA* pVal, int* pErrCode)
{

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->current_mode, pErrCode) )
    {
        return FALSE;
    }



    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->frame_counter, pErrCode) )
    {
        return FALSE;
    }



    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->target_range, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->target_datation, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->retro1_range, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->retro1_datation, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->retro2_range, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->retro2_datation, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_TGM_DATA_Encode(asn1T_PFS_TGM_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_TGM_DATA_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode data-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->data_is_available);

    /*Encode current-mode (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->current_mode, pBitStrm, pErrCode, FALSE);

    /*Encode target-data-valid (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->target_data_valid);

    /*Encode on-line-bit-result (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->on_line_bit_result);

    /*Encode frame-counter (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->frame_counter, pBitStrm, pErrCode, FALSE);

    /*Encode retro1-data-valid (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->retro1_data_valid);

    /*Encode retro2-data-valid (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->retro2_data_valid);

    /*Encode target-range (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->target_range, pBitStrm, pErrCode, FALSE);

    /*Encode target-datation (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->target_datation, pBitStrm, pErrCode, FALSE);

    /*Encode retro1-range (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->retro1_range, pBitStrm, pErrCode, FALSE);

    /*Encode retro1-datation (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->retro1_datation, pBitStrm, pErrCode, FALSE);

    /*Encode retro2-range (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->retro2_range, pBitStrm, pErrCode, FALSE);

    /*Encode retro2-datation (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->retro2_datation, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_TGM_DATA_Decode(asn1T_PFS_TGM_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode data-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->data_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode current-mode (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->current_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode target-data-valid (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->target_data_valid)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode on-line-bit-result (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->on_line_bit_result)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode frame-counter (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->frame_counter, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode retro1-data-valid (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->retro1_data_valid)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode retro2-data-valid (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->retro2_data_valid)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode target-range (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->target_range, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode target-datation (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->target_datation, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode retro1-range (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->retro1_range, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode retro1-datation (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->retro1_datation, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode retro2-range (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->retro2_range, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode retro2-datation (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->retro2_datation, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_POWER_CONSUMPTION_Initialize(asn1T_POWER_CONSUMPTION* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_POWER_CONSUMPTION_IsConstraintValid(asn1T_POWER_CONSUMPTION* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_POWER_CONSUMPTION_Encode(asn1T_POWER_CONSUMPTION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_POWER_CONSUMPTION_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_POWER_CONSUMPTION_Decode(asn1T_POWER_CONSUMPTION* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_QUATERNION_Initialize(asn1T_QUATERNION* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_QUATERNION_IsConstraintValid(asn1T_QUATERNION* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_QUATERNION;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_QUATERNION_Encode(asn1T_QUATERNION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_QUATERNION_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_QUATERNION_Decode(asn1T_QUATERNION* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_SEQUENCER_CONFIGURATION_Initialize(asn1T_SEQUENCER_CONFIGURATION* pVal)
{

    pVal->pde1_pde4_config_is_selected = FALSE;
    pVal->pde1_is_available = FALSE;
    pVal->pde2_is_available = FALSE;
    pVal->pde3_is_available = FALSE;
    pVal->pde4_is_available = FALSE;
    pVal->dpu_reset_is_requested = FALSE;
    asn1T_INTEGER_Initialize(&pVal->cam_duration);
    pVal->cam_boost_only_is_requested = FALSE;
    pVal->halt_mode_is_requested = FALSE;
}


flag asn1T_SEQUENCER_CONFIGURATION_IsConstraintValid(asn1T_SEQUENCER_CONFIGURATION* pVal, int* pErrCode)
{






    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->cam_duration, pErrCode) )
    {
        return FALSE;
    }



    return TRUE;
}

flag asn1T_SEQUENCER_CONFIGURATION_Encode(asn1T_SEQUENCER_CONFIGURATION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_SEQUENCER_CONFIGURATION_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pde1-pde4-config-is-selected (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde1_pde4_config_is_selected);

    /*Encode pde1-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde1_is_available);

    /*Encode pde2-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde2_is_available);

    /*Encode pde3-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde3_is_available);

    /*Encode pde4-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pde4_is_available);

    /*Encode dpu-reset-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->dpu_reset_is_requested);

    /*Encode cam-duration (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->cam_duration, pBitStrm, pErrCode, FALSE);

    /*Encode cam-boost-only-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->cam_boost_only_is_requested);

    /*Encode halt-mode-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->halt_mode_is_requested);

    return TRUE;
}

flag asn1T_SEQUENCER_CONFIGURATION_Decode(asn1T_SEQUENCER_CONFIGURATION* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pde1-pde4-config-is-selected (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde1_pde4_config_is_selected)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde1-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde1_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde2-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde2_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde3-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde3_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pde4-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pde4_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode dpu-reset-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->dpu_reset_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cam-duration (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->cam_duration, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cam-boost-only-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->cam_boost_only_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode halt-mode-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->halt_mode_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_SW_WARNING_CODE_Initialize(asn1T_SW_WARNING_CODE* pVal)
{

    asn1T_INTEGER_Initialize(pVal);
}


flag asn1T_SW_WARNING_CODE_IsConstraintValid(asn1T_SW_WARNING_CODE* pVal, int* pErrCode)
{
    if ( !asn1T_INTEGER_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_SW_WARNING_CODE_Encode(asn1T_SW_WARNING_CODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_SW_WARNING_CODE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_INTEGER_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_SW_WARNING_CODE_Decode(asn1T_SW_WARNING_CODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_INTEGER_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_SYNCHRO_BROADCAST_STATUS_Initialize(asn1T_SYNCHRO_BROADCAST_STATUS* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        pVal->arr[i1] = FALSE;
    }
}


flag asn1T_SYNCHRO_BROADCAST_STATUS_IsConstraintValid(asn1T_SYNCHRO_BROADCAST_STATUS* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_SYNCHRO_BROADCAST_STATUS;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
    }
    return TRUE;
}

flag asn1T_SYNCHRO_BROADCAST_STATUS_Encode(asn1T_SYNCHRO_BROADCAST_STATUS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_SYNCHRO_BROADCAST_STATUS_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (BOOLEAN)*/
        BitStream_AppendBit(pBitStrm, pVal->arr[i1]);
    }
    return TRUE;
}

flag asn1T_SYNCHRO_BROADCAST_STATUS_Decode(asn1T_SYNCHRO_BROADCAST_STATUS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (BOOLEAN)*/
        if (!BitStream_ReadBit(pBitStrm, &pVal->arr[i1])) { 
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_TEMP_Initialize(asn1T_TEMP* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_TEMP_IsConstraintValid(asn1T_TEMP* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_TEMP_Encode(asn1T_TEMP* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_TEMP_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_TEMP_Decode(asn1T_TEMP* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_THRUSTERS_OPENING_Initialize(asn1T_THRUSTERS_OPENING* pVal)
{

    asn1T_FCV_OPENING_DUR_CMD_Initialize(&pVal->thrusters_opening_pde1);
    asn1T_FCV_OPENING_DUR_CMD_Initialize(&pVal->thrusters_opening_pde2);
}


flag asn1T_THRUSTERS_OPENING_IsConstraintValid(asn1T_THRUSTERS_OPENING* pVal, int* pErrCode)
{
    if ( !asn1T_FCV_OPENING_DUR_CMD_IsConstraintValid(&pVal->thrusters_opening_pde1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_FCV_OPENING_DUR_CMD_IsConstraintValid(&pVal->thrusters_opening_pde2, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_THRUSTERS_OPENING_Encode(asn1T_THRUSTERS_OPENING* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_THRUSTERS_OPENING_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode thrusters-opening-pde1 (T-FCV-OPENING-DUR-CMD)*/
    asn1T_FCV_OPENING_DUR_CMD_Encode(&pVal->thrusters_opening_pde1, pBitStrm, pErrCode, FALSE);

    /*Encode thrusters-opening-pde2 (T-FCV-OPENING-DUR-CMD)*/
    asn1T_FCV_OPENING_DUR_CMD_Encode(&pVal->thrusters_opening_pde2, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_THRUSTERS_OPENING_Decode(asn1T_THRUSTERS_OPENING* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode thrusters-opening-pde1 (T-FCV-OPENING-DUR-CMD)*/
    if ( !asn1T_FCV_OPENING_DUR_CMD_Decode(&pVal->thrusters_opening_pde1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode thrusters-opening-pde2 (T-FCV-OPENING-DUR-CMD)*/
    if ( !asn1T_FCV_OPENING_DUR_CMD_Decode(&pVal->thrusters_opening_pde2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_Initialize(asn1T_TORQUE_EFFICIENCY_MATRIX_LINE* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_IsConstraintValid(asn1T_TORQUE_EFFICIENCY_MATRIX_LINE* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_TORQUE_EFFICIENCY_MATRIX_LINE;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_Encode(asn1T_TORQUE_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_Decode(asn1T_TORQUE_EFFICIENCY_MATRIX_LINE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_TORQUE_EFFICIENCY_MATRIX_Initialize(asn1T_TORQUE_EFFICIENCY_MATRIX* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_TORQUE_EFFICIENCY_MATRIX_IsConstraintValid(asn1T_TORQUE_EFFICIENCY_MATRIX* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_TORQUE_EFFICIENCY_MATRIX;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_TORQUE_EFFICIENCY_MATRIX_Encode(asn1T_TORQUE_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_TORQUE_EFFICIENCY_MATRIX_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-TORQUE-EFFICIENCY-MATRIX-LINE)*/
        asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_TORQUE_EFFICIENCY_MATRIX_Decode(asn1T_TORQUE_EFFICIENCY_MATRIX* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-TORQUE-EFFICIENCY-MATRIX-LINE)*/
        if ( !asn1T_TORQUE_EFFICIENCY_MATRIX_LINE_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR12_Initialize(asn1T_VECTOR12* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<12;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR12_IsConstraintValid(asn1T_VECTOR12* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 12)) ) {
        *pErrCode = ERR_asn1T_VECTOR12;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR12_Encode(asn1T_VECTOR12* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR12_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (12)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR12_Decode(asn1T_VECTOR12* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 12;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR18_Initialize(asn1T_VECTOR18* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<18;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR18_IsConstraintValid(asn1T_VECTOR18* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 18)) ) {
        *pErrCode = ERR_asn1T_VECTOR18;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR18_Encode(asn1T_VECTOR18* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR18_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (18)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR18_Decode(asn1T_VECTOR18* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 18;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR3_Initialize(asn1T_VECTOR3* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR3_IsConstraintValid(asn1T_VECTOR3* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 3)) ) {
        *pErrCode = ERR_asn1T_VECTOR3;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR3_Encode(asn1T_VECTOR3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR3_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR3_Decode(asn1T_VECTOR3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 3;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR4_Initialize(asn1T_VECTOR4* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR4_IsConstraintValid(asn1T_VECTOR4* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 4)) ) {
        *pErrCode = ERR_asn1T_VECTOR4;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR4_Encode(asn1T_VECTOR4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR4_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (4)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR4_Decode(asn1T_VECTOR4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 4;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR6_Initialize(asn1T_VECTOR6* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<6;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR6_IsConstraintValid(asn1T_VECTOR6* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 6)) ) {
        *pErrCode = ERR_asn1T_VECTOR6;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR6_Encode(asn1T_VECTOR6* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR6_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (6)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR6_Decode(asn1T_VECTOR6* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 6;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR8_Initialize(asn1T_VECTOR8* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<8;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR8_IsConstraintValid(asn1T_VECTOR8* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 8)) ) {
        *pErrCode = ERR_asn1T_VECTOR8;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR8_Encode(asn1T_VECTOR8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR8_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (8)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR8_Decode(asn1T_VECTOR8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 8;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VECTOR9_Initialize(asn1T_VECTOR9* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<9;i1++)
    {
        asn1T_REAL_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_VECTOR9_IsConstraintValid(asn1T_VECTOR9* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 9)) ) {
        *pErrCode = ERR_asn1T_VECTOR9;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_VECTOR9_Encode(asn1T_VECTOR9* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_VECTOR9_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (9)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_VECTOR9_Decode(asn1T_VECTOR9* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 9;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_VELOCITY_Initialize(asn1T_VELOCITY* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_VELOCITY_IsConstraintValid(asn1T_VELOCITY* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_VELOCITY_Encode(asn1T_VELOCITY* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_VELOCITY_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_VELOCITY_Decode(asn1T_VELOCITY* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_VOLTAGE_Initialize(asn1T_VOLTAGE* pVal)
{

    asn1T_REAL_Initialize(pVal);
}


flag asn1T_VOLTAGE_IsConstraintValid(asn1T_VOLTAGE* pVal, int* pErrCode)
{
    if ( !asn1T_REAL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_VOLTAGE_Encode(asn1T_VOLTAGE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_VOLTAGE_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_REAL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_VOLTAGE_Decode(asn1T_VOLTAGE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_REAL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1INTEGER16_Initialize(asn1INTEGER16* pVal)
{

    asn1T_INTEGER_Initialize(pVal);
}


flag asn1INTEGER16_IsConstraintValid(asn1INTEGER16* pVal, int* pErrCode)
{
    if ( !asn1T_INTEGER_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1INTEGER16_Encode(asn1INTEGER16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1INTEGER16_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1T_INTEGER_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1INTEGER16_Decode(asn1INTEGER16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1T_INTEGER_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CAM_MODE_Initialize(asn1T_CAM_MODE* pVal)
{

    pVal->is_in_cam = FALSE;
    pVal->is_in_sa = FALSE;
    pVal->is_in_sp = FALSE;
}


flag asn1T_CAM_MODE_IsConstraintValid(asn1T_CAM_MODE* pVal, int* pErrCode)
{



    return TRUE;
}

flag asn1T_CAM_MODE_Encode(asn1T_CAM_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CAM_MODE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode is-in-cam (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->is_in_cam);

    /*Encode is-in-sa (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->is_in_sa);

    /*Encode is-in-sp (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->is_in_sp);

    return TRUE;
}

flag asn1T_CAM_MODE_Decode(asn1T_CAM_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode is-in-cam (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->is_in_cam)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode is-in-sa (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->is_in_sa)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode is-in-sp (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->is_in_sp)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EC_UPDATE_CONF_MSU_Initialize(asn1T_PFS_EC_UPDATE_CONF_MSU* pVal)
{

    asn1T_CONFIGURATION_TABLE_Initialize(&pVal->configuration_table);
    pVal->new_config_is_available = FALSE;
}


flag asn1T_PFS_EC_UPDATE_CONF_MSU_IsConstraintValid(asn1T_PFS_EC_UPDATE_CONF_MSU* pVal, int* pErrCode)
{
    if ( !asn1T_CONFIGURATION_TABLE_IsConstraintValid(&pVal->configuration_table, pErrCode) )
    {
        return FALSE;
    }


    return TRUE;
}

flag asn1T_PFS_EC_UPDATE_CONF_MSU_Encode(asn1T_PFS_EC_UPDATE_CONF_MSU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EC_UPDATE_CONF_MSU_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode configuration-table (T-CONFIGURATION-TABLE)*/
    asn1T_CONFIGURATION_TABLE_Encode(&pVal->configuration_table, pBitStrm, pErrCode, FALSE);

    /*Encode new-config-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->new_config_is_available);

    return TRUE;
}

flag asn1T_PFS_EC_UPDATE_CONF_MSU_Decode(asn1T_PFS_EC_UPDATE_CONF_MSU* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode configuration-table (T-CONFIGURATION-TABLE)*/
    if ( !asn1T_CONFIGURATION_TABLE_Decode(&pVal->configuration_table, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode new-config-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->new_config_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_MSU_STATE_Initialize(asn1T_MSU_STATE* pVal)
{

    pVal->state_is_pfs_m_standby = FALSE;
    pVal->state_is_pfs_m_ready_for_cam = FALSE;
    pVal->state_is_pfs_m_cam_prgs = FALSE;
    pVal->state_is_pfs_m_cam_inhib = FALSE;
}


flag asn1T_MSU_STATE_IsConstraintValid(asn1T_MSU_STATE* pVal, int* pErrCode)
{




    return TRUE;
}

flag asn1T_MSU_STATE_Encode(asn1T_MSU_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_MSU_STATE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode state-is-pfs-m-standby (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_standby);

    /*Encode state-is-pfs-m-ready-for-cam (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_ready_for_cam);

    /*Encode state-is-pfs-m-cam-prgs (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_cam_prgs);

    /*Encode state-is-pfs-m-cam-inhib (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_cam_inhib);

    return TRUE;
}

flag asn1T_MSU_STATE_Decode(asn1T_MSU_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode state-is-pfs-m-standby (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_standby)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-ready-for-cam (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_ready_for_cam)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-cam-prgs (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_cam_prgs)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-cam-inhib (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_cam_inhib)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_DPU_CMD_Initialize(asn1T_DPU_CMD* pVal)
{

    asn1T_ON_OFF_CMD_Initialize(&pVal->set_pfs_ewc_msu_dpu_reset);
    asn1T_ON_OFF_CMD_Initialize(&pVal->set_pfs_ewc_msu_dpu_cam);
}


flag asn1T_DPU_CMD_IsConstraintValid(asn1T_DPU_CMD* pVal, int* pErrCode)
{
    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_pfs_ewc_msu_dpu_reset, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_pfs_ewc_msu_dpu_cam, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_DPU_CMD_Encode(asn1T_DPU_CMD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_DPU_CMD_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode set-pfs-ewc-msu-dpu-reset (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_pfs_ewc_msu_dpu_reset, pBitStrm, pErrCode, FALSE);

    /*Encode set-pfs-ewc-msu-dpu-cam (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_pfs_ewc_msu_dpu_cam, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_DPU_CMD_Decode(asn1T_DPU_CMD* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode set-pfs-ewc-msu-dpu-reset (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_pfs_ewc_msu_dpu_reset, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-pfs-ewc-msu-dpu-cam (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_pfs_ewc_msu_dpu_cam, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_HLTM_Initialize(asn1T_HLTM* pVal)
{

    pVal->set_pfs_hltm_cam_test2_status = FALSE;
    pVal->set_pfs_hltm_cam_trig_status = FALSE;
    pVal->set_pfs_hltm_msu_master_status = FALSE;
    pVal->set_pfs_hltm_config_status = FALSE;
    pVal->set_pfs_hltm_msu_health_status = FALSE;
    pVal->set_pfs_hltm_ftcp_res_detected = FALSE;
    asn1T_MSU_STATE_Initialize(&pVal->msu_state);
}


flag asn1T_HLTM_IsConstraintValid(asn1T_HLTM* pVal, int* pErrCode)
{






    if ( !asn1T_MSU_STATE_IsConstraintValid(&pVal->msu_state, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_HLTM_Encode(asn1T_HLTM* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_HLTM_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode set-pfs-hltm-cam-test2-status (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_pfs_hltm_cam_test2_status);

    /*Encode set-pfs-hltm-cam-trig-status (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_pfs_hltm_cam_trig_status);

    /*Encode set-pfs-hltm-msu-master-status (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_pfs_hltm_msu_master_status);

    /*Encode set-pfs-hltm-config-status (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_pfs_hltm_config_status);

    /*Encode set-pfs-hltm-msu-health-status (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_pfs_hltm_msu_health_status);

    /*Encode set-pfs-hltm-ftcp-res-detected (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->set_pfs_hltm_ftcp_res_detected);

    /*Encode msu-state (T-MSU-STATE)*/
    asn1T_MSU_STATE_Encode(&pVal->msu_state, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_HLTM_Decode(asn1T_HLTM* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode set-pfs-hltm-cam-test2-status (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_pfs_hltm_cam_test2_status)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-pfs-hltm-cam-trig-status (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_pfs_hltm_cam_trig_status)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-pfs-hltm-msu-master-status (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_pfs_hltm_msu_master_status)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-pfs-hltm-config-status (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_pfs_hltm_config_status)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-pfs-hltm-msu-health-status (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_pfs_hltm_msu_health_status)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-pfs-hltm-ftcp-res-detected (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->set_pfs_hltm_ftcp_res_detected)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-state (T-MSU-STATE)*/
    if ( !asn1T_MSU_STATE_Decode(&pVal->msu_state, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_HLTC_Initialize(asn1T_HLTC* pVal)
{

    pVal->pfs_hltc_update_config_is_on = FALSE;
    asn1T_PFS_EC_UPDATE_CONF_MSU_Initialize(&pVal->pfs_ec_update_config);
    pVal->pfs_hltc_enable_cam_test2_is_on = FALSE;
    pVal->pfs_hltc_disable_cam_test2_on = FALSE;
}


flag asn1T_HLTC_IsConstraintValid(asn1T_HLTC* pVal, int* pErrCode)
{

    if ( !asn1T_PFS_EC_UPDATE_CONF_MSU_IsConstraintValid(&pVal->pfs_ec_update_config, pErrCode) )
    {
        return FALSE;
    }



    return TRUE;
}

flag asn1T_HLTC_Encode(asn1T_HLTC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_HLTC_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-hltc-update-config-is-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_hltc_update_config_is_on);

    /*Encode pfs-ec-update-config (T-PFS-EC-UPDATE-CONF-MSU)*/
    asn1T_PFS_EC_UPDATE_CONF_MSU_Encode(&pVal->pfs_ec_update_config, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-hltc-enable-cam-test2-is-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_hltc_enable_cam_test2_is_on);

    /*Encode pfs-hltc-disable-cam-test2-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_hltc_disable_cam_test2_on);

    return TRUE;
}

flag asn1T_HLTC_Decode(asn1T_HLTC* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-hltc-update-config-is-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_hltc_update_config_is_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ec-update-config (T-PFS-EC-UPDATE-CONF-MSU)*/
    if ( !asn1T_PFS_EC_UPDATE_CONF_MSU_Decode(&pVal->pfs_ec_update_config, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-hltc-enable-cam-test2-is-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_hltc_enable_cam_test2_is_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-hltc-disable-cam-test2-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_hltc_disable_cam_test2_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON_Initialize(asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON* pVal)
{

    asn1MYBOOL_Initialize(pVal);
}


flag asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON_IsConstraintValid(asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON* pVal, int* pErrCode)
{
    if ( !asn1MYBOOL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON_Encode(asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1MYBOOL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON_Decode(asn1T_PFS_IWM_ARMING_RELAY_STATUS_ON* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1MYBOOL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_HLTC_RED_BUTTON_IS_ON_Initialize(asn1T_PFS_HLTC_RED_BUTTON_IS_ON* pVal)
{

    asn1MYBOOL_Initialize(pVal);
}


flag asn1T_PFS_HLTC_RED_BUTTON_IS_ON_IsConstraintValid(asn1T_PFS_HLTC_RED_BUTTON_IS_ON* pVal, int* pErrCode)
{
    if ( !asn1MYBOOL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_PFS_HLTC_RED_BUTTON_IS_ON_Encode(asn1T_PFS_HLTC_RED_BUTTON_IS_ON* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_HLTC_RED_BUTTON_IS_ON_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1MYBOOL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_PFS_HLTC_RED_BUTTON_IS_ON_Decode(asn1T_PFS_HLTC_RED_BUTTON_IS_ON* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1MYBOOL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_END_BOOST_IS_REACHED_Initialize(asn1T_END_BOOST_IS_REACHED* pVal)
{

    asn1MYBOOL_Initialize(pVal);
}


flag asn1T_END_BOOST_IS_REACHED_IsConstraintValid(asn1T_END_BOOST_IS_REACHED* pVal, int* pErrCode)
{
    if ( !asn1MYBOOL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_END_BOOST_IS_REACHED_Encode(asn1T_END_BOOST_IS_REACHED* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_END_BOOST_IS_REACHED_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1MYBOOL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_END_BOOST_IS_REACHED_Decode(asn1T_END_BOOST_IS_REACHED* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1MYBOOL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_SUN_IS_AIMED_Initialize(asn1T_SUN_IS_AIMED* pVal)
{

    asn1MYBOOL_Initialize(pVal);
}


flag asn1T_SUN_IS_AIMED_IsConstraintValid(asn1T_SUN_IS_AIMED* pVal, int* pErrCode)
{
    if ( !asn1MYBOOL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_SUN_IS_AIMED_Encode(asn1T_SUN_IS_AIMED* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_SUN_IS_AIMED_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1MYBOOL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_SUN_IS_AIMED_Decode(asn1T_SUN_IS_AIMED* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1MYBOOL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROLLER_TO_BE_ACTIVATED_Initialize(asn1T_CONTROLLER_TO_BE_ACTIVATED* pVal)
{

    asn1MYBOOL_Initialize(pVal);
}


flag asn1T_CONTROLLER_TO_BE_ACTIVATED_IsConstraintValid(asn1T_CONTROLLER_TO_BE_ACTIVATED* pVal, int* pErrCode)
{
    if ( !asn1MYBOOL_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    return TRUE;
}

flag asn1T_CONTROLLER_TO_BE_ACTIVATED_Encode(asn1T_CONTROLLER_TO_BE_ACTIVATED* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROLLER_TO_BE_ACTIVATED_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    asn1MYBOOL_Encode(pVal, pBitStrm, pErrCode, FALSE);
    return TRUE;
}

flag asn1T_CONTROLLER_TO_BE_ACTIVATED_Decode(asn1T_CONTROLLER_TO_BE_ACTIVATED* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if ( !asn1MYBOOL_Decode(pVal, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROL_UP_OUT_Initialize(asn1T_CONTROL_UP_OUT* pVal)
{

    asn1T_THRUSTERS_OPENING_Initialize(&pVal->thrusters_opening);
}


flag asn1T_CONTROL_UP_OUT_IsConstraintValid(asn1T_CONTROL_UP_OUT* pVal, int* pErrCode)
{
    if ( !asn1T_THRUSTERS_OPENING_IsConstraintValid(&pVal->thrusters_opening, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROL_UP_OUT_Encode(asn1T_CONTROL_UP_OUT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROL_UP_OUT_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode thrusters-opening (T-THRUSTERS-OPENING)*/
    asn1T_THRUSTERS_OPENING_Encode(&pVal->thrusters_opening, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROL_UP_OUT_Decode(asn1T_CONTROL_UP_OUT* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode thrusters-opening (T-THRUSTERS-OPENING)*/
    if ( !asn1T_THRUSTERS_OPENING_Decode(&pVal->thrusters_opening, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROL_DOWN_OUT_Initialize(asn1T_CONTROL_DOWN_OUT* pVal)
{

    asn1T_END_BOOST_IS_REACHED_Initialize(&pVal->end_boost_is_reached);
    asn1T_SUN_IS_AIMED_Initialize(&pVal->sun_is_aimed);
}


flag asn1T_CONTROL_DOWN_OUT_IsConstraintValid(asn1T_CONTROL_DOWN_OUT* pVal, int* pErrCode)
{
    if ( !asn1T_END_BOOST_IS_REACHED_IsConstraintValid(&pVal->end_boost_is_reached, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_SUN_IS_AIMED_IsConstraintValid(&pVal->sun_is_aimed, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROL_DOWN_OUT_Encode(asn1T_CONTROL_DOWN_OUT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROL_DOWN_OUT_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode end-boost-is-reached (T-END-BOOST-IS-REACHED)*/
    asn1T_END_BOOST_IS_REACHED_Encode(&pVal->end_boost_is_reached, pBitStrm, pErrCode, FALSE);

    /*Encode sun-is-aimed (T-SUN-IS-AIMED)*/
    asn1T_SUN_IS_AIMED_Encode(&pVal->sun_is_aimed, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROL_DOWN_OUT_Decode(asn1T_CONTROL_DOWN_OUT* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode end-boost-is-reached (T-END-BOOST-IS-REACHED)*/
    if ( !asn1T_END_BOOST_IS_REACHED_Decode(&pVal->end_boost_is_reached, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode sun-is-aimed (T-SUN-IS-AIMED)*/
    if ( !asn1T_SUN_IS_AIMED_Decode(&pVal->sun_is_aimed, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CAM_CMD_Initialize(asn1T_CAM_CMD* pVal)
{

    asn1T_ON_OFF_CMD_Initialize(&pVal->set_cam_cmd_pde1);
    asn1T_ON_OFF_CMD_Initialize(&pVal->set_cam_cmd_pde2);
    asn1T_ON_OFF_CMD_Initialize(&pVal->set_cam_cmd_pde3);
    asn1T_ON_OFF_CMD_Initialize(&pVal->set_cam_cmd_pde4);
}


flag asn1T_CAM_CMD_IsConstraintValid(asn1T_CAM_CMD* pVal, int* pErrCode)
{
    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_cam_cmd_pde1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_cam_cmd_pde2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_cam_cmd_pde3, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_cam_cmd_pde4, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CAM_CMD_Encode(asn1T_CAM_CMD* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CAM_CMD_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode set-cam-cmd-pde1 (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_cam_cmd_pde1, pBitStrm, pErrCode, FALSE);

    /*Encode set-cam-cmd-pde2 (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_cam_cmd_pde2, pBitStrm, pErrCode, FALSE);

    /*Encode set-cam-cmd-pde3 (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_cam_cmd_pde3, pBitStrm, pErrCode, FALSE);

    /*Encode set-cam-cmd-pde4 (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_cam_cmd_pde4, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CAM_CMD_Decode(asn1T_CAM_CMD* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode set-cam-cmd-pde1 (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_cam_cmd_pde1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-cam-cmd-pde2 (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_cam_cmd_pde2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-cam-cmd-pde3 (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_cam_cmd_pde3, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode set-cam-cmd-pde4 (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_cam_cmd_pde4, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CM_CONFIGURATION_Initialize(asn1T_CM_CONFIGURATION* pVal)
{

    int i1 = 0;

    asn1T_REAL_Initialize(&pVal->angular_rate_threshold);
    asn1T_INTEGER_Initialize(&pVal->rdv_phase);
    pVal->boost_monitoring_opening_date.nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_INTEGER_Initialize(&pVal->boost_monitoring_opening_date.arr[i1]);
    }
    pVal->boost_threshold_dvx.nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->boost_threshold_dvx.arr[i1]);
    }
    pVal->boost_threshold_dvz.nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->boost_threshold_dvz.arr[i1]);
    }
    pVal->boost_monitoring_duration.nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_INTEGER_Initialize(&pVal->boost_monitoring_duration.arr[i1]);
    }
    pVal->acca_bias_estimation.nCount = 0;
    for(i1=0;i1<6;i1++)
    {
        asn1T_REAL_Initialize(&pVal->acca_bias_estimation.arr[i1]);
    }
    asn1T_REAL_Initialize(&pVal->zm_threshold_initial);
    asn1T_REAL_Initialize(&pVal->zm_threshold_final);
    asn1T_REAL_Initialize(&pVal->mc_threshold_initial);
    asn1T_REAL_Initialize(&pVal->mc_threshold_final);
    asn1T_REAL_Initialize(&pVal->zm_initial);
    asn1T_REAL_Initialize(&pVal->zm_final);
    pVal->r_r_rate_threshold_curve.nCount = 0;
    for(i1=0;i1<12;i1++)
    {
        asn1T_REAL_Initialize(&pVal->r_r_rate_threshold_curve.arr[i1]);
    }
    pVal->boost_intensities_dvx.nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->boost_intensities_dvx.arr[i1]);
    }
    pVal->boost_intensities_dvz.nCount = 0;
    for(i1=0;i1<3;i1++)
    {
        asn1T_REAL_Initialize(&pVal->boost_intensities_dvz.arr[i1]);
    }
    asn1T_VECTOR6_Initialize(&pVal->acca_lsb_value_acm);
    asn1T_VECTOR6_Initialize(&pVal->acca_bias_estimate);
    asn1T_VECTOR18_Initialize(&pVal->pseudo_inverse_acm);
    asn1T_VECTOR4_Initialize(&pVal->tgm_window_size);
    asn1T_VECTOR4_Initialize(&pVal->tgm_range_ref);
}


flag asn1T_CM_CONFIGURATION_IsConstraintValid(asn1T_CM_CONFIGURATION* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !asn1T_REAL_IsConstraintValid(&pVal->angular_rate_threshold, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->rdv_phase, pErrCode) )
    {
        return FALSE;
    }

    if ( !((pVal->boost_monitoring_opening_date.nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_boost_monitoring_opening_date;
        return FALSE;
    }

    for(i1=0;i1<pVal->boost_monitoring_opening_date.nCount;i1++)
    {
        if ( !asn1T_INTEGER_IsConstraintValid(&pVal->boost_monitoring_opening_date.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->boost_threshold_dvx.nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_boost_threshold_dvx;
        return FALSE;
    }

    for(i1=0;i1<pVal->boost_threshold_dvx.nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->boost_threshold_dvx.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->boost_threshold_dvz.nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_boost_threshold_dvz;
        return FALSE;
    }

    for(i1=0;i1<pVal->boost_threshold_dvz.nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->boost_threshold_dvz.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->boost_monitoring_duration.nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_boost_monitoring_duration;
        return FALSE;
    }

    for(i1=0;i1<pVal->boost_monitoring_duration.nCount;i1++)
    {
        if ( !asn1T_INTEGER_IsConstraintValid(&pVal->boost_monitoring_duration.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->acca_bias_estimation.nCount == 6)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_acca_bias_estimation;
        return FALSE;
    }

    for(i1=0;i1<pVal->acca_bias_estimation.nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->acca_bias_estimation.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->zm_threshold_initial, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->zm_threshold_final, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->mc_threshold_initial, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->mc_threshold_final, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->zm_initial, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->zm_final, pErrCode) )
    {
        return FALSE;
    }

    if ( !((pVal->r_r_rate_threshold_curve.nCount == 12)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_r_r_rate_threshold_curve;
        return FALSE;
    }

    for(i1=0;i1<pVal->r_r_rate_threshold_curve.nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->r_r_rate_threshold_curve.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->boost_intensities_dvx.nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_boost_intensities_dvx;
        return FALSE;
    }

    for(i1=0;i1<pVal->boost_intensities_dvx.nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->boost_intensities_dvx.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !((pVal->boost_intensities_dvz.nCount == 3)) ) {
        *pErrCode = ERR_asn1T_CM_CONFIGURATION_boost_intensities_dvz;
        return FALSE;
    }

    for(i1=0;i1<pVal->boost_intensities_dvz.nCount;i1++)
    {
        if ( !asn1T_REAL_IsConstraintValid(&pVal->boost_intensities_dvz.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !asn1T_VECTOR6_IsConstraintValid(&pVal->acca_lsb_value_acm, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR6_IsConstraintValid(&pVal->acca_bias_estimate, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR18_IsConstraintValid(&pVal->pseudo_inverse_acm, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR4_IsConstraintValid(&pVal->tgm_window_size, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR4_IsConstraintValid(&pVal->tgm_range_ref, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CM_CONFIGURATION_Encode(asn1T_CM_CONFIGURATION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_CM_CONFIGURATION_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode angular-rate-threshold (T-REAL)*/
    asn1T_REAL_Encode(&pVal->angular_rate_threshold, pBitStrm, pErrCode, FALSE);

    /*Encode rdv-phase (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->rdv_phase, pBitStrm, pErrCode, FALSE);

    /*Encode boost-monitoring-opening-date (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->boost_monitoring_opening_date.nCount;i1++)
    {
        /*Encode childlen : (T-INTEGER)*/
        asn1T_INTEGER_Encode(&pVal->boost_monitoring_opening_date.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode boost-threshold-dvx (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->boost_threshold_dvx.nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->boost_threshold_dvx.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode boost-threshold-dvz (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->boost_threshold_dvz.nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->boost_threshold_dvz.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode boost-monitoring-duration (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->boost_monitoring_duration.nCount;i1++)
    {
        /*Encode childlen : (T-INTEGER)*/
        asn1T_INTEGER_Encode(&pVal->boost_monitoring_duration.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode acca-bias-estimation (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (6)*/
    for(i1=0;i1<pVal->acca_bias_estimation.nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->acca_bias_estimation.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode zm-threshold-initial (T-REAL)*/
    asn1T_REAL_Encode(&pVal->zm_threshold_initial, pBitStrm, pErrCode, FALSE);

    /*Encode zm-threshold-final (T-REAL)*/
    asn1T_REAL_Encode(&pVal->zm_threshold_final, pBitStrm, pErrCode, FALSE);

    /*Encode mc-threshold-initial (T-REAL)*/
    asn1T_REAL_Encode(&pVal->mc_threshold_initial, pBitStrm, pErrCode, FALSE);

    /*Encode mc-threshold-final (T-REAL)*/
    asn1T_REAL_Encode(&pVal->mc_threshold_final, pBitStrm, pErrCode, FALSE);

    /*Encode zm-initial (T-REAL)*/
    asn1T_REAL_Encode(&pVal->zm_initial, pBitStrm, pErrCode, FALSE);

    /*Encode zm-final (T-REAL)*/
    asn1T_REAL_Encode(&pVal->zm_final, pBitStrm, pErrCode, FALSE);

    /*Encode r-r-rate-threshold-curve (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (12)*/
    for(i1=0;i1<pVal->r_r_rate_threshold_curve.nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->r_r_rate_threshold_curve.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode boost-intensities-dvx (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->boost_intensities_dvx.nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->boost_intensities_dvx.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode boost-intensities-dvz (SEQUENCE OF)*/
    /* No need to encode length (it is fixed size (3)*/
    for(i1=0;i1<pVal->boost_intensities_dvz.nCount;i1++)
    {
        /*Encode childlen : (T-REAL)*/
        asn1T_REAL_Encode(&pVal->boost_intensities_dvz.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode acca-lsb-value-acm (T-VECTOR6)*/
    asn1T_VECTOR6_Encode(&pVal->acca_lsb_value_acm, pBitStrm, pErrCode, FALSE);

    /*Encode acca-bias-estimate (T-VECTOR6)*/
    asn1T_VECTOR6_Encode(&pVal->acca_bias_estimate, pBitStrm, pErrCode, FALSE);

    /*Encode pseudo-inverse-acm (T-VECTOR18)*/
    asn1T_VECTOR18_Encode(&pVal->pseudo_inverse_acm, pBitStrm, pErrCode, FALSE);

    /*Encode tgm-window-size (T-VECTOR4)*/
    asn1T_VECTOR4_Encode(&pVal->tgm_window_size, pBitStrm, pErrCode, FALSE);

    /*Encode tgm-range-ref (T-VECTOR4)*/
    asn1T_VECTOR4_Encode(&pVal->tgm_range_ref, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CM_CONFIGURATION_Decode(asn1T_CM_CONFIGURATION* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

        /*Decode angular-rate-threshold (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->angular_rate_threshold, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode rdv-phase (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->rdv_phase, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode boost-monitoring-opening-date (SEQUENCE OF)*/
    pVal->boost_monitoring_opening_date.nCount = 3;
    for(i1=0;i1<pVal->boost_monitoring_opening_date.nCount;i1++)
    {
        /*Decode childlen : (T-INTEGER)*/
        if ( !asn1T_INTEGER_Decode(&pVal->boost_monitoring_opening_date.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode boost-threshold-dvx (SEQUENCE OF)*/
    pVal->boost_threshold_dvx.nCount = 3;
    for(i1=0;i1<pVal->boost_threshold_dvx.nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->boost_threshold_dvx.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode boost-threshold-dvz (SEQUENCE OF)*/
    pVal->boost_threshold_dvz.nCount = 3;
    for(i1=0;i1<pVal->boost_threshold_dvz.nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->boost_threshold_dvz.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode boost-monitoring-duration (SEQUENCE OF)*/
    pVal->boost_monitoring_duration.nCount = 3;
    for(i1=0;i1<pVal->boost_monitoring_duration.nCount;i1++)
    {
        /*Decode childlen : (T-INTEGER)*/
        if ( !asn1T_INTEGER_Decode(&pVal->boost_monitoring_duration.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode acca-bias-estimation (SEQUENCE OF)*/
    pVal->acca_bias_estimation.nCount = 6;
    for(i1=0;i1<pVal->acca_bias_estimation.nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->acca_bias_estimation.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode zm-threshold-initial (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->zm_threshold_initial, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode zm-threshold-final (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->zm_threshold_final, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode mc-threshold-initial (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->mc_threshold_initial, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode mc-threshold-final (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->mc_threshold_final, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode zm-initial (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->zm_initial, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode zm-final (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->zm_final, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode r-r-rate-threshold-curve (SEQUENCE OF)*/
    pVal->r_r_rate_threshold_curve.nCount = 12;
    for(i1=0;i1<pVal->r_r_rate_threshold_curve.nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->r_r_rate_threshold_curve.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode boost-intensities-dvx (SEQUENCE OF)*/
    pVal->boost_intensities_dvx.nCount = 3;
    for(i1=0;i1<pVal->boost_intensities_dvx.nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->boost_intensities_dvx.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode boost-intensities-dvz (SEQUENCE OF)*/
    pVal->boost_intensities_dvz.nCount = 3;
    for(i1=0;i1<pVal->boost_intensities_dvz.nCount;i1++)
    {
        /*Decode childlen : (T-REAL)*/
        if ( !asn1T_REAL_Decode(&pVal->boost_intensities_dvz.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode acca-lsb-value-acm (T-VECTOR6)*/
    if ( !asn1T_VECTOR6_Decode(&pVal->acca_lsb_value_acm, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode acca-bias-estimate (T-VECTOR6)*/
    if ( !asn1T_VECTOR6_Decode(&pVal->acca_bias_estimate, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pseudo-inverse-acm (T-VECTOR18)*/
    if ( !asn1T_VECTOR18_Decode(&pVal->pseudo_inverse_acm, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tgm-window-size (T-VECTOR4)*/
    if ( !asn1T_VECTOR4_Decode(&pVal->tgm_window_size, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tgm-range-ref (T-VECTOR4)*/
    if ( !asn1T_VECTOR4_Decode(&pVal->tgm_range_ref, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROLLER_CONFIG_Initialize(asn1T_CONTROLLER_CONFIG* pVal)
{

    asn1T_MASS_Initialize(&pVal->atv_mass);
    asn1T_INERTIA_Initialize(&pVal->inertia);
    asn1T_VECTOR3_Initialize(&pVal->center_of_mass);
    asn1T_INITIAL_EFFICIENCY_MATRIX_Initialize(&pVal->initial_efficiency_matrix);
    asn1T_EFFICIENCY_MATRIX_Initialize(&pVal->inverse_efficiency_matrix);
    asn1T_VELOCITY_Initialize(&pVal->aimed_delta_v);
    asn1T_QUATERNION_Initialize(&pVal->q_lof_to_atv_cam_inst);
    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_atv_sasp_inst);
    asn1T_REAL_Initialize(&pVal->orbital_pulsation);
}


flag asn1T_CONTROLLER_CONFIG_IsConstraintValid(asn1T_CONTROLLER_CONFIG* pVal, int* pErrCode)
{
    if ( !asn1T_MASS_IsConstraintValid(&pVal->atv_mass, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INERTIA_IsConstraintValid(&pVal->inertia, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR3_IsConstraintValid(&pVal->center_of_mass, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INITIAL_EFFICIENCY_MATRIX_IsConstraintValid(&pVal->initial_efficiency_matrix, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_EFFICIENCY_MATRIX_IsConstraintValid(&pVal->inverse_efficiency_matrix, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VELOCITY_IsConstraintValid(&pVal->aimed_delta_v, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_lof_to_atv_cam_inst, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_atv_sasp_inst, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->orbital_pulsation, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROLLER_CONFIG_Encode(asn1T_CONTROLLER_CONFIG* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROLLER_CONFIG_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode atv-mass (T-MASS)*/
    asn1T_MASS_Encode(&pVal->atv_mass, pBitStrm, pErrCode, FALSE);

    /*Encode inertia (T-INERTIA)*/
    asn1T_INERTIA_Encode(&pVal->inertia, pBitStrm, pErrCode, FALSE);

    /*Encode center-of-mass (T-VECTOR3)*/
    asn1T_VECTOR3_Encode(&pVal->center_of_mass, pBitStrm, pErrCode, FALSE);

    /*Encode initial-efficiency-matrix (T-INITIAL-EFFICIENCY-MATRIX)*/
    asn1T_INITIAL_EFFICIENCY_MATRIX_Encode(&pVal->initial_efficiency_matrix, pBitStrm, pErrCode, FALSE);

    /*Encode inverse-efficiency-matrix (T-EFFICIENCY-MATRIX)*/
    asn1T_EFFICIENCY_MATRIX_Encode(&pVal->inverse_efficiency_matrix, pBitStrm, pErrCode, FALSE);

    /*Encode aimed-delta-v (T-VELOCITY)*/
    asn1T_VELOCITY_Encode(&pVal->aimed_delta_v, pBitStrm, pErrCode, FALSE);

    /*Encode q-lof-to-atv-cam-inst (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_lof_to_atv_cam_inst, pBitStrm, pErrCode, FALSE);

    /*Encode q-j2000-to-atv-sasp-inst (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_atv_sasp_inst, pBitStrm, pErrCode, FALSE);

    /*Encode orbital-pulsation (T-REAL)*/
    asn1T_REAL_Encode(&pVal->orbital_pulsation, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROLLER_CONFIG_Decode(asn1T_CONTROLLER_CONFIG* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode atv-mass (T-MASS)*/
    if ( !asn1T_MASS_Decode(&pVal->atv_mass, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode inertia (T-INERTIA)*/
    if ( !asn1T_INERTIA_Decode(&pVal->inertia, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode center-of-mass (T-VECTOR3)*/
    if ( !asn1T_VECTOR3_Decode(&pVal->center_of_mass, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode initial-efficiency-matrix (T-INITIAL-EFFICIENCY-MATRIX)*/
    if ( !asn1T_INITIAL_EFFICIENCY_MATRIX_Decode(&pVal->initial_efficiency_matrix, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode inverse-efficiency-matrix (T-EFFICIENCY-MATRIX)*/
    if ( !asn1T_EFFICIENCY_MATRIX_Decode(&pVal->inverse_efficiency_matrix, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode aimed-delta-v (T-VELOCITY)*/
    if ( !asn1T_VELOCITY_Decode(&pVal->aimed_delta_v, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-lof-to-atv-cam-inst (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_lof_to_atv_cam_inst, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-j2000-to-atv-sasp-inst (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_atv_sasp_inst, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode orbital-pulsation (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->orbital_pulsation, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROLLER_FILTER_STATE_Initialize(asn1T_CONTROLLER_FILTER_STATE* pVal)
{

    asn1T_MATRIX_3_4_Initialize(&pVal->input);
    asn1T_MATRIX_3_4_Initialize(&pVal->output);
}


flag asn1T_CONTROLLER_FILTER_STATE_IsConstraintValid(asn1T_CONTROLLER_FILTER_STATE* pVal, int* pErrCode)
{
    if ( !asn1T_MATRIX_3_4_IsConstraintValid(&pVal->input, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_MATRIX_3_4_IsConstraintValid(&pVal->output, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROLLER_FILTER_STATE_Encode(asn1T_CONTROLLER_FILTER_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROLLER_FILTER_STATE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode input (T-MATRIX-3-4)*/
    asn1T_MATRIX_3_4_Encode(&pVal->input, pBitStrm, pErrCode, FALSE);

    /*Encode output (T-MATRIX-3-4)*/
    asn1T_MATRIX_3_4_Encode(&pVal->output, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROLLER_FILTER_STATE_Decode(asn1T_CONTROLLER_FILTER_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode input (T-MATRIX-3-4)*/
    if ( !asn1T_MATRIX_3_4_Decode(&pVal->input, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode output (T-MATRIX-3-4)*/
    if ( !asn1T_MATRIX_3_4_Decode(&pVal->output, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROLLER_STATE_Initialize(asn1T_CONTROLLER_STATE* pVal)
{

    asn1T_QUATERNION_Initialize(&pVal->q_lof_to_atv);
    asn1T_ANGULAR_RATE_Initialize(&pVal->atv_abs_angular_rates);
    asn1T_ACCELERATION_Initialize(&pVal->atv_disruptive_acceleration);
}


flag asn1T_CONTROLLER_STATE_IsConstraintValid(asn1T_CONTROLLER_STATE* pVal, int* pErrCode)
{
    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_lof_to_atv, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ANGULAR_RATE_IsConstraintValid(&pVal->atv_abs_angular_rates, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ACCELERATION_IsConstraintValid(&pVal->atv_disruptive_acceleration, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROLLER_STATE_Encode(asn1T_CONTROLLER_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROLLER_STATE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode q-lof-to-atv (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_lof_to_atv, pBitStrm, pErrCode, FALSE);

    /*Encode atv-abs-angular-rates (T-ANGULAR-RATE)*/
    asn1T_ANGULAR_RATE_Encode(&pVal->atv_abs_angular_rates, pBitStrm, pErrCode, FALSE);

    /*Encode atv-disruptive-acceleration (T-ACCELERATION)*/
    asn1T_ACCELERATION_Encode(&pVal->atv_disruptive_acceleration, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROLLER_STATE_Decode(asn1T_CONTROLLER_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode q-lof-to-atv (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_lof_to_atv, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode atv-abs-angular-rates (T-ANGULAR-RATE)*/
    if ( !asn1T_ANGULAR_RATE_Decode(&pVal->atv_abs_angular_rates, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode atv-disruptive-acceleration (T-ACCELERATION)*/
    if ( !asn1T_ACCELERATION_Decode(&pVal->atv_disruptive_acceleration, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROLLER_TELEMETRY_Initialize(asn1T_CONTROLLER_TELEMETRY* pVal)
{

    asn1T_VELOCITY_Initialize(&pVal->estimated_delta_v);
    asn1T_THRUSTERS_OPENING_Initialize(&pVal->thrusters_opening);
    asn1T_REAL_Initialize(&pVal->estimated_atv_quaternion_1);
    asn1T_REAL_Initialize(&pVal->estimated_atv_quaternion_2);
    asn1T_REAL_Initialize(&pVal->estimated_atv_quaternion_3);
}


flag asn1T_CONTROLLER_TELEMETRY_IsConstraintValid(asn1T_CONTROLLER_TELEMETRY* pVal, int* pErrCode)
{
    if ( !asn1T_VELOCITY_IsConstraintValid(&pVal->estimated_delta_v, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_THRUSTERS_OPENING_IsConstraintValid(&pVal->thrusters_opening, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->estimated_atv_quaternion_1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->estimated_atv_quaternion_2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->estimated_atv_quaternion_3, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROLLER_TELEMETRY_Encode(asn1T_CONTROLLER_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROLLER_TELEMETRY_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode estimated-delta-v (T-VELOCITY)*/
    asn1T_VELOCITY_Encode(&pVal->estimated_delta_v, pBitStrm, pErrCode, FALSE);

    /*Encode thrusters-opening (T-THRUSTERS-OPENING)*/
    asn1T_THRUSTERS_OPENING_Encode(&pVal->thrusters_opening, pBitStrm, pErrCode, FALSE);

    /*Encode estimated-atv-quaternion-1 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->estimated_atv_quaternion_1, pBitStrm, pErrCode, FALSE);

    /*Encode estimated-atv-quaternion-2 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->estimated_atv_quaternion_2, pBitStrm, pErrCode, FALSE);

    /*Encode estimated-atv-quaternion-3 (T-REAL)*/
    asn1T_REAL_Encode(&pVal->estimated_atv_quaternion_3, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROLLER_TELEMETRY_Decode(asn1T_CONTROLLER_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode estimated-delta-v (T-VELOCITY)*/
    if ( !asn1T_VELOCITY_Decode(&pVal->estimated_delta_v, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode thrusters-opening (T-THRUSTERS-OPENING)*/
    if ( !asn1T_THRUSTERS_OPENING_Decode(&pVal->thrusters_opening, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode estimated-atv-quaternion-1 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->estimated_atv_quaternion_1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode estimated-atv-quaternion-2 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->estimated_atv_quaternion_2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode estimated-atv-quaternion-3 (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->estimated_atv_quaternion_3, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_HW_STATUSES_Initialize(asn1T_HW_STATUSES* pVal)
{

    pVal->power_sensor_enable = FALSE;
    pVal->output_sensor_enable = FALSE;
    pVal->flag_dtg1_power_enabled = FALSE;
    pVal->flag_dtg2_power_enabled = FALSE;
    pVal->flag_lcl_status_pde1 = FALSE;
    pVal->flag_lcl_status_pde2 = FALSE;
    pVal->flag_lcl_status_pde3 = FALSE;
    pVal->flag_lcl_status_pde4 = FALSE;
    pVal->flag_hlct_red_button_from_cpf1 = FALSE;
    pVal->flag_hlct_red_button_from_cpf2 = FALSE;
    asn1T_PFS_EWM_MSU_MSU_HS_Initialize(&pVal->pfs_ewm_msuy_msux_hs);
    pVal->flag_hltc_disarm_from_cpf1 = FALSE;
    pVal->flag_hltc_disarm_from_cpf2 = FALSE;
    pVal->flag_hltc_arm_from_cpf1 = FALSE;
    pVal->flag_hltc_arm_from_cpf2 = FALSE;
    pVal->flag_pde_power_sensor = FALSE;
    pVal->flag_aux_bat_sensor = FALSE;
}


flag asn1T_HW_STATUSES_IsConstraintValid(asn1T_HW_STATUSES* pVal, int* pErrCode)
{










    if ( !asn1T_PFS_EWM_MSU_MSU_HS_IsConstraintValid(&pVal->pfs_ewm_msuy_msux_hs, pErrCode) )
    {
        return FALSE;
    }







    return TRUE;
}

flag asn1T_HW_STATUSES_Encode(asn1T_HW_STATUSES* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_HW_STATUSES_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode power-sensor-enable (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->power_sensor_enable);

    /*Encode output-sensor-enable (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->output_sensor_enable);

    /*Encode flag-dtg1-power-enabled (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_dtg1_power_enabled);

    /*Encode flag-dtg2-power-enabled (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_dtg2_power_enabled);

    /*Encode flag-lcl-status-pde1 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_lcl_status_pde1);

    /*Encode flag-lcl-status-pde2 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_lcl_status_pde2);

    /*Encode flag-lcl-status-pde3 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_lcl_status_pde3);

    /*Encode flag-lcl-status-pde4 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_lcl_status_pde4);

    /*Encode flag-hlct-red-button-from-cpf1 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_hlct_red_button_from_cpf1);

    /*Encode flag-hlct-red-button-from-cpf2 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_hlct_red_button_from_cpf2);

    /*Encode pfs-ewm-msuy-msux-hs (T-PFS-EWM-MSU-MSU-HS)*/
    asn1T_PFS_EWM_MSU_MSU_HS_Encode(&pVal->pfs_ewm_msuy_msux_hs, pBitStrm, pErrCode, FALSE);

    /*Encode flag-hltc-disarm-from-cpf1 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_hltc_disarm_from_cpf1);

    /*Encode flag-hltc-disarm-from-cpf2 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_hltc_disarm_from_cpf2);

    /*Encode flag-hltc-arm-from-cpf1 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_hltc_arm_from_cpf1);

    /*Encode flag-hltc-arm-from-cpf2 (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_hltc_arm_from_cpf2);

    /*Encode flag-pde-power-sensor (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_pde_power_sensor);

    /*Encode flag-aux-bat-sensor (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->flag_aux_bat_sensor);

    return TRUE;
}

flag asn1T_HW_STATUSES_Decode(asn1T_HW_STATUSES* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode power-sensor-enable (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->power_sensor_enable)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode output-sensor-enable (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->output_sensor_enable)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-dtg1-power-enabled (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_dtg1_power_enabled)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-dtg2-power-enabled (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_dtg2_power_enabled)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-lcl-status-pde1 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_lcl_status_pde1)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-lcl-status-pde2 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_lcl_status_pde2)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-lcl-status-pde3 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_lcl_status_pde3)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-lcl-status-pde4 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_lcl_status_pde4)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-hlct-red-button-from-cpf1 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_hlct_red_button_from_cpf1)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-hlct-red-button-from-cpf2 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_hlct_red_button_from_cpf2)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-msuy-msux-hs (T-PFS-EWM-MSU-MSU-HS)*/
    if ( !asn1T_PFS_EWM_MSU_MSU_HS_Decode(&pVal->pfs_ewm_msuy_msux_hs, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-hltc-disarm-from-cpf1 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_hltc_disarm_from_cpf1)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-hltc-disarm-from-cpf2 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_hltc_disarm_from_cpf2)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-hltc-arm-from-cpf1 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_hltc_arm_from_cpf1)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-hltc-arm-from-cpf2 (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_hltc_arm_from_cpf2)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-pde-power-sensor (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_pde_power_sensor)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode flag-aux-bat-sensor (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->flag_aux_bat_sensor)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_NAVIGATION_CONFIGURATION_Initialize(asn1T_NAVIGATION_CONFIGURATION* pVal)
{

    asn1T_QUATERNION_Initialize(&pVal->q_lof_to_atv_cam_inst);
    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_atv_sasp_inst);
    asn1T_REAL_Initialize(&pVal->orbital_pulsation);
    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_ocf);
    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_atv);
    asn1T_VECTOR4_Initialize(&pVal->coarse_drift_msu);
    asn1T_VECTOR4_Initialize(&pVal->fine_drift_msu);
    asn1T_VECTOR8_Initialize(&pVal->dtg_lsb_value_msu);
    asn1T_REAL_Initialize(&pVal->dtg_fd_fine_threshold);
    asn1T_REAL_Initialize(&pVal->dtg_fd_coarse_threshold);
    asn1T_VECTOR12_Initialize(&pVal->ssu_calib_data_msu);
    asn1T_VECTOR9_Initialize(&pVal->true_ssu_axis_to_atv);
    asn1T_VECTOR12_Initialize(&pVal->true_dtg_axis_to_atv_msu);
    asn1T_VECTOR4_Initialize(&pVal->estimated_flight_drifts_config);
}


flag asn1T_NAVIGATION_CONFIGURATION_IsConstraintValid(asn1T_NAVIGATION_CONFIGURATION* pVal, int* pErrCode)
{
    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_lof_to_atv_cam_inst, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_atv_sasp_inst, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->orbital_pulsation, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_ocf, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_atv, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR4_IsConstraintValid(&pVal->coarse_drift_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR4_IsConstraintValid(&pVal->fine_drift_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR8_IsConstraintValid(&pVal->dtg_lsb_value_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->dtg_fd_fine_threshold, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_REAL_IsConstraintValid(&pVal->dtg_fd_coarse_threshold, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR12_IsConstraintValid(&pVal->ssu_calib_data_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR9_IsConstraintValid(&pVal->true_ssu_axis_to_atv, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR12_IsConstraintValid(&pVal->true_dtg_axis_to_atv_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VECTOR4_IsConstraintValid(&pVal->estimated_flight_drifts_config, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_NAVIGATION_CONFIGURATION_Encode(asn1T_NAVIGATION_CONFIGURATION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_NAVIGATION_CONFIGURATION_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode q-lof-to-atv-cam-inst (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_lof_to_atv_cam_inst, pBitStrm, pErrCode, FALSE);

    /*Encode q-j2000-to-atv-sasp-inst (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_atv_sasp_inst, pBitStrm, pErrCode, FALSE);

    /*Encode orbital-pulsation (T-REAL)*/
    asn1T_REAL_Encode(&pVal->orbital_pulsation, pBitStrm, pErrCode, FALSE);

    /*Encode q-j2000-to-ocf (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_ocf, pBitStrm, pErrCode, FALSE);

    /*Encode q-j2000-to-atv (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_atv, pBitStrm, pErrCode, FALSE);

    /*Encode coarse-drift-msu (T-VECTOR4)*/
    asn1T_VECTOR4_Encode(&pVal->coarse_drift_msu, pBitStrm, pErrCode, FALSE);

    /*Encode fine-drift-msu (T-VECTOR4)*/
    asn1T_VECTOR4_Encode(&pVal->fine_drift_msu, pBitStrm, pErrCode, FALSE);

    /*Encode dtg-lsb-value-msu (T-VECTOR8)*/
    asn1T_VECTOR8_Encode(&pVal->dtg_lsb_value_msu, pBitStrm, pErrCode, FALSE);

    /*Encode dtg-fd-fine-threshold (T-REAL)*/
    asn1T_REAL_Encode(&pVal->dtg_fd_fine_threshold, pBitStrm, pErrCode, FALSE);

    /*Encode dtg-fd-coarse-threshold (T-REAL)*/
    asn1T_REAL_Encode(&pVal->dtg_fd_coarse_threshold, pBitStrm, pErrCode, FALSE);

    /*Encode ssu-calib-data-msu (T-VECTOR12)*/
    asn1T_VECTOR12_Encode(&pVal->ssu_calib_data_msu, pBitStrm, pErrCode, FALSE);

    /*Encode true-ssu-axis-to-atv (T-VECTOR9)*/
    asn1T_VECTOR9_Encode(&pVal->true_ssu_axis_to_atv, pBitStrm, pErrCode, FALSE);

    /*Encode true-dtg-axis-to-atv-msu (T-VECTOR12)*/
    asn1T_VECTOR12_Encode(&pVal->true_dtg_axis_to_atv_msu, pBitStrm, pErrCode, FALSE);

    /*Encode estimated-flight-drifts-config (T-VECTOR4)*/
    asn1T_VECTOR4_Encode(&pVal->estimated_flight_drifts_config, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_NAVIGATION_CONFIGURATION_Decode(asn1T_NAVIGATION_CONFIGURATION* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode q-lof-to-atv-cam-inst (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_lof_to_atv_cam_inst, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-j2000-to-atv-sasp-inst (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_atv_sasp_inst, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode orbital-pulsation (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->orbital_pulsation, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-j2000-to-ocf (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_ocf, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-j2000-to-atv (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_atv, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode coarse-drift-msu (T-VECTOR4)*/
    if ( !asn1T_VECTOR4_Decode(&pVal->coarse_drift_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode fine-drift-msu (T-VECTOR4)*/
    if ( !asn1T_VECTOR4_Decode(&pVal->fine_drift_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode dtg-lsb-value-msu (T-VECTOR8)*/
    if ( !asn1T_VECTOR8_Decode(&pVal->dtg_lsb_value_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode dtg-fd-fine-threshold (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->dtg_fd_fine_threshold, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode dtg-fd-coarse-threshold (T-REAL)*/
    if ( !asn1T_REAL_Decode(&pVal->dtg_fd_coarse_threshold, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode ssu-calib-data-msu (T-VECTOR12)*/
    if ( !asn1T_VECTOR12_Decode(&pVal->ssu_calib_data_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode true-ssu-axis-to-atv (T-VECTOR9)*/
    if ( !asn1T_VECTOR9_Decode(&pVal->true_ssu_axis_to_atv, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode true-dtg-axis-to-atv-msu (T-VECTOR12)*/
    if ( !asn1T_VECTOR12_Decode(&pVal->true_dtg_axis_to_atv_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode estimated-flight-drifts-config (T-VECTOR4)*/
    if ( !asn1T_VECTOR4_Decode(&pVal->estimated_flight_drifts_config, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_NAVIGATION_OUTPUT_Initialize(asn1T_NAVIGATION_OUTPUT* pVal)
{

    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_atv_nav);
    asn1T_QUATERNION_Initialize(&pVal->q_lof_to_atv_nav);
    asn1T_ANGULAR_RATE_Initialize(&pVal->atv_abs_ang_rate_nav);
}


flag asn1T_NAVIGATION_OUTPUT_IsConstraintValid(asn1T_NAVIGATION_OUTPUT* pVal, int* pErrCode)
{
    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_atv_nav, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_lof_to_atv_nav, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ANGULAR_RATE_IsConstraintValid(&pVal->atv_abs_ang_rate_nav, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_NAVIGATION_OUTPUT_Encode(asn1T_NAVIGATION_OUTPUT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_NAVIGATION_OUTPUT_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode q-j2000-to-atv-nav (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_atv_nav, pBitStrm, pErrCode, FALSE);

    /*Encode q-lof-to-atv-nav (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_lof_to_atv_nav, pBitStrm, pErrCode, FALSE);

    /*Encode atv-abs-ang-rate-nav (T-ANGULAR-RATE)*/
    asn1T_ANGULAR_RATE_Encode(&pVal->atv_abs_ang_rate_nav, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_NAVIGATION_OUTPUT_Decode(asn1T_NAVIGATION_OUTPUT* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode q-j2000-to-atv-nav (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_atv_nav, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-lof-to-atv-nav (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_lof_to_atv_nav, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode atv-abs-ang-rate-nav (T-ANGULAR-RATE)*/
    if ( !asn1T_ANGULAR_RATE_Decode(&pVal->atv_abs_ang_rate_nav, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_NAVIGATION_STATE_Initialize(asn1T_NAVIGATION_STATE* pVal)
{

    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_atv);
    asn1T_QUATERNION_Initialize(&pVal->q_lof_to_atv);
    asn1T_QUATERNION_Initialize(&pVal->q_j2000_to_atv_unconfir);
    asn1T_QUATERNION_Initialize(&pVal->q_lof_to_atv_unconfir);
}


flag asn1T_NAVIGATION_STATE_IsConstraintValid(asn1T_NAVIGATION_STATE* pVal, int* pErrCode)
{
    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_atv, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_lof_to_atv, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_j2000_to_atv_unconfir, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_QUATERNION_IsConstraintValid(&pVal->q_lof_to_atv_unconfir, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_NAVIGATION_STATE_Encode(asn1T_NAVIGATION_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_NAVIGATION_STATE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode q-j2000-to-atv (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_atv, pBitStrm, pErrCode, FALSE);

    /*Encode q-lof-to-atv (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_lof_to_atv, pBitStrm, pErrCode, FALSE);

    /*Encode q-j2000-to-atv-unconfir (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_j2000_to_atv_unconfir, pBitStrm, pErrCode, FALSE);

    /*Encode q-lof-to-atv-unconfir (T-QUATERNION)*/
    asn1T_QUATERNION_Encode(&pVal->q_lof_to_atv_unconfir, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_NAVIGATION_STATE_Decode(asn1T_NAVIGATION_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode q-j2000-to-atv (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_atv, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-lof-to-atv (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_lof_to_atv, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-j2000-to-atv-unconfir (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_j2000_to_atv_unconfir, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode q-lof-to-atv-unconfir (T-QUATERNION)*/
    if ( !asn1T_QUATERNION_Decode(&pVal->q_lof_to_atv_unconfir, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_NAVIGATION_TELEMETRY_Initialize(asn1T_NAVIGATION_TELEMETRY* pVal)
{

    pVal->pfs_dtg_is_failed = FALSE;
    asn1T_ANGLE_Initialize(&pVal->alpha_ssu);
    asn1T_ANGLE_Initialize(&pVal->beta_ssu);
    asn1T_NAVIGATION_OUTPUT_Initialize(&pVal->navigation_output);
}


flag asn1T_NAVIGATION_TELEMETRY_IsConstraintValid(asn1T_NAVIGATION_TELEMETRY* pVal, int* pErrCode)
{

    if ( !asn1T_ANGLE_IsConstraintValid(&pVal->alpha_ssu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_ANGLE_IsConstraintValid(&pVal->beta_ssu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_NAVIGATION_OUTPUT_IsConstraintValid(&pVal->navigation_output, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_NAVIGATION_TELEMETRY_Encode(asn1T_NAVIGATION_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_NAVIGATION_TELEMETRY_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-dtg-is-failed (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_dtg_is_failed);

    /*Encode alpha-ssu (T-ANGLE)*/
    asn1T_ANGLE_Encode(&pVal->alpha_ssu, pBitStrm, pErrCode, FALSE);

    /*Encode beta-ssu (T-ANGLE)*/
    asn1T_ANGLE_Encode(&pVal->beta_ssu, pBitStrm, pErrCode, FALSE);

    /*Encode navigation-output (T-NAVIGATION-OUTPUT)*/
    asn1T_NAVIGATION_OUTPUT_Encode(&pVal->navigation_output, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_NAVIGATION_TELEMETRY_Decode(asn1T_NAVIGATION_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-dtg-is-failed (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_dtg_is_failed)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode alpha-ssu (T-ANGLE)*/
    if ( !asn1T_ANGLE_Decode(&pVal->alpha_ssu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode beta-ssu (T-ANGLE)*/
    if ( !asn1T_ANGLE_Decode(&pVal->beta_ssu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode navigation-output (T-NAVIGATION-OUTPUT)*/
    if ( !asn1T_NAVIGATION_OUTPUT_Decode(&pVal->navigation_output, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_BUS_DATA_BLOCK_Initialize(asn1T_PFS_BUS_DATA_BLOCK* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<32;i1++)
    {
        asn1INTEGER16_Initialize(&pVal->arr[i1]);
    }
}


flag asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(asn1T_PFS_BUS_DATA_BLOCK* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !((pVal->nCount == 32)) ) {
        *pErrCode = ERR_asn1T_PFS_BUS_DATA_BLOCK;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !asn1INTEGER16_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag asn1T_PFS_BUS_DATA_BLOCK_Encode(asn1T_PFS_BUS_DATA_BLOCK* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* No need to encode length (it is fixed size (32)*/
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (INTEGER16)*/
        asn1INTEGER16_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
    }
    return TRUE;
}

flag asn1T_PFS_BUS_DATA_BLOCK_Decode(asn1T_PFS_BUS_DATA_BLOCK* pVal, BitStream* pBitStrm, int* pErrCode)
{
    long nCount = 0;
    int i1 = 0;

    pVal->nCount = 32;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (INTEGER16)*/
        if ( !asn1INTEGER16_Decode(&pVal->arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void asn1T_PFS_BUS_SENSOR_DATA_Initialize(asn1T_PFS_BUS_SENSOR_DATA* pVal)
{

    asn1T_PFS_TGM_DATA_Initialize(&pVal->pfs_tgm1_data);
    asn1T_PFS_TGM_DATA_Initialize(&pVal->pfs_tgm2_data);
    asn1T_PFS_ACM_DATA_Initialize(&pVal->pfs_acm1_data);
    asn1T_PFS_ACM_DATA_Initialize(&pVal->pfs_acm2_data);
    asn1T_PFS_ACM_DATA_Initialize(&pVal->pfs_acm3_data);
}


flag asn1T_PFS_BUS_SENSOR_DATA_IsConstraintValid(asn1T_PFS_BUS_SENSOR_DATA* pVal, int* pErrCode)
{
    if ( !asn1T_PFS_TGM_DATA_IsConstraintValid(&pVal->pfs_tgm1_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_TGM_DATA_IsConstraintValid(&pVal->pfs_tgm2_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_ACM_DATA_IsConstraintValid(&pVal->pfs_acm1_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_ACM_DATA_IsConstraintValid(&pVal->pfs_acm2_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_ACM_DATA_IsConstraintValid(&pVal->pfs_acm3_data, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_BUS_SENSOR_DATA_Encode(asn1T_PFS_BUS_SENSOR_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_BUS_SENSOR_DATA_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-tgm1-data (T-PFS-TGM-DATA)*/
    asn1T_PFS_TGM_DATA_Encode(&pVal->pfs_tgm1_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-tgm2-data (T-PFS-TGM-DATA)*/
    asn1T_PFS_TGM_DATA_Encode(&pVal->pfs_tgm2_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-acm1-data (T-PFS-ACM-DATA)*/
    asn1T_PFS_ACM_DATA_Encode(&pVal->pfs_acm1_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-acm2-data (T-PFS-ACM-DATA)*/
    asn1T_PFS_ACM_DATA_Encode(&pVal->pfs_acm2_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-acm3-data (T-PFS-ACM-DATA)*/
    asn1T_PFS_ACM_DATA_Encode(&pVal->pfs_acm3_data, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_BUS_SENSOR_DATA_Decode(asn1T_PFS_BUS_SENSOR_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-tgm1-data (T-PFS-TGM-DATA)*/
    if ( !asn1T_PFS_TGM_DATA_Decode(&pVal->pfs_tgm1_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-tgm2-data (T-PFS-TGM-DATA)*/
    if ( !asn1T_PFS_TGM_DATA_Decode(&pVal->pfs_tgm2_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-acm1-data (T-PFS-ACM-DATA)*/
    if ( !asn1T_PFS_ACM_DATA_Decode(&pVal->pfs_acm1_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-acm2-data (T-PFS-ACM-DATA)*/
    if ( !asn1T_PFS_ACM_DATA_Decode(&pVal->pfs_acm2_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-acm3-data (T-PFS-ACM-DATA)*/
    if ( !asn1T_PFS_ACM_DATA_Decode(&pVal->pfs_acm3_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EWM_DTG12_MSU_MODE_Initialize(asn1T_PFS_EWM_DTG12_MSU_MODE* pVal)
{

    asn1T_PFS_EWM_DTG_MSU_MODE_Initialize(&pVal->dtg1_mode);
    asn1T_PFS_EWM_DTG_MSU_MODE_Initialize(&pVal->dtg2_mode);
}


flag asn1T_PFS_EWM_DTG12_MSU_MODE_IsConstraintValid(asn1T_PFS_EWM_DTG12_MSU_MODE* pVal, int* pErrCode)
{
    if ( !asn1T_PFS_EWM_DTG_MSU_MODE_IsConstraintValid(&pVal->dtg1_mode, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_EWM_DTG_MSU_MODE_IsConstraintValid(&pVal->dtg2_mode, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_EWM_DTG12_MSU_MODE_Encode(asn1T_PFS_EWM_DTG12_MSU_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWM_DTG12_MSU_MODE_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode dtg1-mode (T-PFS-EWM-DTG-MSU-MODE)*/
    asn1T_PFS_EWM_DTG_MSU_MODE_Encode(&pVal->dtg1_mode, pBitStrm, pErrCode, FALSE);

    /*Encode dtg2-mode (T-PFS-EWM-DTG-MSU-MODE)*/
    asn1T_PFS_EWM_DTG_MSU_MODE_Encode(&pVal->dtg2_mode, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_EWM_DTG12_MSU_MODE_Decode(asn1T_PFS_EWM_DTG12_MSU_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode dtg1-mode (T-PFS-EWM-DTG-MSU-MODE)*/
    if ( !asn1T_PFS_EWM_DTG_MSU_MODE_Decode(&pVal->dtg1_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode dtg2-mode (T-PFS-EWM-DTG-MSU-MODE)*/
    if ( !asn1T_PFS_EWM_DTG_MSU_MODE_Decode(&pVal->dtg2_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EWM_DTG_MSU_Initialize(asn1T_PFS_EWM_DTG_MSU* pVal)
{

    asn1T_PFS_EWM_DTG_MSU_MODE_Initialize(&pVal->pfs_ewm_dtg_msu_mode);
    asn1T_INTEGER_Initialize(&pVal->pfs_ewm_dtg_msu_axis1);
    asn1T_INTEGER_Initialize(&pVal->pfs_ewm_dtg_msu_axis2);
}


flag asn1T_PFS_EWM_DTG_MSU_IsConstraintValid(asn1T_PFS_EWM_DTG_MSU* pVal, int* pErrCode)
{
    if ( !asn1T_PFS_EWM_DTG_MSU_MODE_IsConstraintValid(&pVal->pfs_ewm_dtg_msu_mode, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->pfs_ewm_dtg_msu_axis1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->pfs_ewm_dtg_msu_axis2, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_EWM_DTG_MSU_Encode(asn1T_PFS_EWM_DTG_MSU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWM_DTG_MSU_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-ewm-dtg-msu-mode (T-PFS-EWM-DTG-MSU-MODE)*/
    asn1T_PFS_EWM_DTG_MSU_MODE_Encode(&pVal->pfs_ewm_dtg_msu_mode, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-dtg-msu-axis1 (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->pfs_ewm_dtg_msu_axis1, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-dtg-msu-axis2 (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->pfs_ewm_dtg_msu_axis2, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_EWM_DTG_MSU_Decode(asn1T_PFS_EWM_DTG_MSU* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-ewm-dtg-msu-mode (T-PFS-EWM-DTG-MSU-MODE)*/
    if ( !asn1T_PFS_EWM_DTG_MSU_MODE_Decode(&pVal->pfs_ewm_dtg_msu_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-dtg-msu-axis1 (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->pfs_ewm_dtg_msu_axis1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-dtg-msu-axis2 (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->pfs_ewm_dtg_msu_axis2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_IWM_MEASUREMENTS_Initialize(asn1T_PFS_IWM_MEASUREMENTS* pVal)
{

    asn1T_VOLTAGE_Initialize(&pVal->pfs_iwm_voltage_cpu);
    asn1T_VOLTAGE_Initialize(&pVal->pfs_iwm_voltage_pos);
    asn1T_VOLTAGE_Initialize(&pVal->pfs_iwm_voltage_neg);
    asn1T_VOLTAGE_Initialize(&pVal->pfs_iwm_voltage_bat);
    asn1T_CURRENT_Initialize(&pVal->pfs_ewm_current_ssu1);
    asn1T_CURRENT_Initialize(&pVal->pfs_ewm_current_ssu2);
    asn1T_CURRENT_Initialize(&pVal->pfs_ewm_current_ssu3);
    asn1T_CURRENT_Initialize(&pVal->pfs_ewm_current_ssu4);
    asn1T_CURRENT_Initialize(&pVal->pfs_iwm_current_pde1);
    asn1T_CURRENT_Initialize(&pVal->pfs_iwm_current_pde2);
    asn1T_CURRENT_Initialize(&pVal->pfs_iwm_current_pde3);
    asn1T_CURRENT_Initialize(&pVal->pfs_iwm_current_pde4);
    asn1T_CURRENT_Initialize(&pVal->pfs_iwm_current_prim);
    asn1T_VOLTAGE_Initialize(&pVal->pfs_iwm_voltage_prim);
    asn1T_TEMP_Initialize(&pVal->pfs_iwm_temp_msu);
    asn1T_TEMP_Initialize(&pVal->pfs_iwm_temp_gyro);
}


flag asn1T_PFS_IWM_MEASUREMENTS_IsConstraintValid(asn1T_PFS_IWM_MEASUREMENTS* pVal, int* pErrCode)
{
    if ( !asn1T_VOLTAGE_IsConstraintValid(&pVal->pfs_iwm_voltage_cpu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VOLTAGE_IsConstraintValid(&pVal->pfs_iwm_voltage_pos, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VOLTAGE_IsConstraintValid(&pVal->pfs_iwm_voltage_neg, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VOLTAGE_IsConstraintValid(&pVal->pfs_iwm_voltage_bat, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_ewm_current_ssu1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_ewm_current_ssu2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_ewm_current_ssu3, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_ewm_current_ssu4, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_iwm_current_pde1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_iwm_current_pde2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_iwm_current_pde3, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_iwm_current_pde4, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CURRENT_IsConstraintValid(&pVal->pfs_iwm_current_prim, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_VOLTAGE_IsConstraintValid(&pVal->pfs_iwm_voltage_prim, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_TEMP_IsConstraintValid(&pVal->pfs_iwm_temp_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_TEMP_IsConstraintValid(&pVal->pfs_iwm_temp_gyro, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_IWM_MEASUREMENTS_Encode(asn1T_PFS_IWM_MEASUREMENTS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_IWM_MEASUREMENTS_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-iwm-voltage-cpu (T-VOLTAGE)*/
    asn1T_VOLTAGE_Encode(&pVal->pfs_iwm_voltage_cpu, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-voltage-pos (T-VOLTAGE)*/
    asn1T_VOLTAGE_Encode(&pVal->pfs_iwm_voltage_pos, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-voltage-neg (T-VOLTAGE)*/
    asn1T_VOLTAGE_Encode(&pVal->pfs_iwm_voltage_neg, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-voltage-bat (T-VOLTAGE)*/
    asn1T_VOLTAGE_Encode(&pVal->pfs_iwm_voltage_bat, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-current-ssu1 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_ewm_current_ssu1, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-current-ssu2 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_ewm_current_ssu2, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-current-ssu3 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_ewm_current_ssu3, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-current-ssu4 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_ewm_current_ssu4, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-current-pde1 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_iwm_current_pde1, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-current-pde2 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_iwm_current_pde2, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-current-pde3 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_iwm_current_pde3, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-current-pde4 (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_iwm_current_pde4, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-current-prim (T-CURRENT)*/
    asn1T_CURRENT_Encode(&pVal->pfs_iwm_current_prim, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-voltage-prim (T-VOLTAGE)*/
    asn1T_VOLTAGE_Encode(&pVal->pfs_iwm_voltage_prim, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-temp-msu (T-TEMP)*/
    asn1T_TEMP_Encode(&pVal->pfs_iwm_temp_msu, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwm-temp-gyro (T-TEMP)*/
    asn1T_TEMP_Encode(&pVal->pfs_iwm_temp_gyro, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_IWM_MEASUREMENTS_Decode(asn1T_PFS_IWM_MEASUREMENTS* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-iwm-voltage-cpu (T-VOLTAGE)*/
    if ( !asn1T_VOLTAGE_Decode(&pVal->pfs_iwm_voltage_cpu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-voltage-pos (T-VOLTAGE)*/
    if ( !asn1T_VOLTAGE_Decode(&pVal->pfs_iwm_voltage_pos, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-voltage-neg (T-VOLTAGE)*/
    if ( !asn1T_VOLTAGE_Decode(&pVal->pfs_iwm_voltage_neg, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-voltage-bat (T-VOLTAGE)*/
    if ( !asn1T_VOLTAGE_Decode(&pVal->pfs_iwm_voltage_bat, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-current-ssu1 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_ewm_current_ssu1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-current-ssu2 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_ewm_current_ssu2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-current-ssu3 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_ewm_current_ssu3, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-current-ssu4 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_ewm_current_ssu4, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-current-pde1 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_iwm_current_pde1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-current-pde2 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_iwm_current_pde2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-current-pde3 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_iwm_current_pde3, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-current-pde4 (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_iwm_current_pde4, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-current-prim (T-CURRENT)*/
    if ( !asn1T_CURRENT_Decode(&pVal->pfs_iwm_current_prim, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-voltage-prim (T-VOLTAGE)*/
    if ( !asn1T_VOLTAGE_Decode(&pVal->pfs_iwm_voltage_prim, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-temp-msu (T-TEMP)*/
    if ( !asn1T_TEMP_Decode(&pVal->pfs_iwm_temp_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-temp-gyro (T-TEMP)*/
    if ( !asn1T_TEMP_Decode(&pVal->pfs_iwm_temp_gyro, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PDE_CMD_A_Initialize(asn1T_PDE_CMD_A* pVal)
{

    asn1T_ON_OFF_CMD_Initialize(&pVal->set_pfs_iwc_cam_trig1);
    asn1T_CAM_CMD_Initialize(&pVal->pfs_iwc_pde_cam_trig2);
    asn1T_CAM_CMD_Initialize(&pVal->pfs_ewc_msu_pde_cmd1);
    asn1T_CAM_CMD_Initialize(&pVal->pfs_ewc_msu_pde_cmd2);
}


flag asn1T_PDE_CMD_A_IsConstraintValid(asn1T_PDE_CMD_A* pVal, int* pErrCode)
{
    if ( !asn1T_ON_OFF_CMD_IsConstraintValid(&pVal->set_pfs_iwc_cam_trig1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CAM_CMD_IsConstraintValid(&pVal->pfs_iwc_pde_cam_trig2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CAM_CMD_IsConstraintValid(&pVal->pfs_ewc_msu_pde_cmd1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CAM_CMD_IsConstraintValid(&pVal->pfs_ewc_msu_pde_cmd2, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PDE_CMD_A_Encode(asn1T_PDE_CMD_A* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PDE_CMD_A_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode set-pfs-iwc-cam-trig1 (T-ON-OFF-CMD)*/
    asn1T_ON_OFF_CMD_Encode(&pVal->set_pfs_iwc_cam_trig1, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-iwc-pde-cam-trig2 (T-CAM-CMD)*/
    asn1T_CAM_CMD_Encode(&pVal->pfs_iwc_pde_cam_trig2, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewc-msu-pde-cmd1 (T-CAM-CMD)*/
    asn1T_CAM_CMD_Encode(&pVal->pfs_ewc_msu_pde_cmd1, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewc-msu-pde-cmd2 (T-CAM-CMD)*/
    asn1T_CAM_CMD_Encode(&pVal->pfs_ewc_msu_pde_cmd2, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PDE_CMD_A_Decode(asn1T_PDE_CMD_A* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode set-pfs-iwc-cam-trig1 (T-ON-OFF-CMD)*/
    if ( !asn1T_ON_OFF_CMD_Decode(&pVal->set_pfs_iwc_cam_trig1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwc-pde-cam-trig2 (T-CAM-CMD)*/
    if ( !asn1T_CAM_CMD_Decode(&pVal->pfs_iwc_pde_cam_trig2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewc-msu-pde-cmd1 (T-CAM-CMD)*/
    if ( !asn1T_CAM_CMD_Decode(&pVal->pfs_ewc_msu_pde_cmd1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewc-msu-pde-cmd2 (T-CAM-CMD)*/
    if ( !asn1T_CAM_CMD_Decode(&pVal->pfs_ewc_msu_pde_cmd2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_CONTROL_IN_Initialize(asn1T_CONTROL_IN* pVal)
{

    asn1T_CAM_MODE_Initialize(&pVal->cam_mode);
    asn1T_CONTROLLER_TO_BE_ACTIVATED_Initialize(&pVal->controller_to_be_activated);
    asn1T_NAVIGATION_OUTPUT_Initialize(&pVal->navigation_output);
}


flag asn1T_CONTROL_IN_IsConstraintValid(asn1T_CONTROL_IN* pVal, int* pErrCode)
{
    if ( !asn1T_CAM_MODE_IsConstraintValid(&pVal->cam_mode, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CONTROLLER_TO_BE_ACTIVATED_IsConstraintValid(&pVal->controller_to_be_activated, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_NAVIGATION_OUTPUT_IsConstraintValid(&pVal->navigation_output, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_CONTROL_IN_Encode(asn1T_CONTROL_IN* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_CONTROL_IN_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode cam-mode (T-CAM-MODE)*/
    asn1T_CAM_MODE_Encode(&pVal->cam_mode, pBitStrm, pErrCode, FALSE);

    /*Encode controller-to-be-activated (T-CONTROLLER-TO-BE-ACTIVATED)*/
    asn1T_CONTROLLER_TO_BE_ACTIVATED_Encode(&pVal->controller_to_be_activated, pBitStrm, pErrCode, FALSE);

    /*Encode navigation-output (T-NAVIGATION-OUTPUT)*/
    asn1T_NAVIGATION_OUTPUT_Encode(&pVal->navigation_output, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_CONTROL_IN_Decode(asn1T_CONTROL_IN* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode cam-mode (T-CAM-MODE)*/
    if ( !asn1T_CAM_MODE_Decode(&pVal->cam_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode controller-to-be-activated (T-CONTROLLER-TO-BE-ACTIVATED)*/
    if ( !asn1T_CONTROLLER_TO_BE_ACTIVATED_Decode(&pVal->controller_to_be_activated, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode navigation-output (T-NAVIGATION-OUTPUT)*/
    if ( !asn1T_NAVIGATION_OUTPUT_Decode(&pVal->navigation_output, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_1BUS_DATA_Initialize(asn1T_PFS_1BUS_DATA* pVal)
{

    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->synchro_block);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block1);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block2);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block3);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block4);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block5);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block6);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block7);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block8);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block9);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tc_block0);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->acm_block);
    asn1T_PFS_BUS_DATA_BLOCK_Initialize(&pVal->tgm_block1);
}


flag asn1T_PFS_1BUS_DATA_IsConstraintValid(asn1T_PFS_1BUS_DATA* pVal, int* pErrCode)
{
    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->synchro_block, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block1, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block2, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block3, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block4, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block5, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block6, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block7, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block8, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block9, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tc_block0, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->acm_block, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_BUS_DATA_BLOCK_IsConstraintValid(&pVal->tgm_block1, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_1BUS_DATA_Encode(asn1T_PFS_1BUS_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_1BUS_DATA_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode synchro-block (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->synchro_block, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block1 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block1, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block2 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block2, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block3 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block3, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block4 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block4, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block5 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block5, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block6 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block6, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block7 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block7, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block8 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block8, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block9 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block9, pBitStrm, pErrCode, FALSE);

    /*Encode tc-block0 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tc_block0, pBitStrm, pErrCode, FALSE);

    /*Encode acm-block (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->acm_block, pBitStrm, pErrCode, FALSE);

    /*Encode tgm-block1 (T-PFS-BUS-DATA-BLOCK)*/
    asn1T_PFS_BUS_DATA_BLOCK_Encode(&pVal->tgm_block1, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_1BUS_DATA_Decode(asn1T_PFS_1BUS_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode synchro-block (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->synchro_block, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block1 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block2 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block2, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block3 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block3, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block4 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block4, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block5 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block5, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block6 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block6, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block7 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block7, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block8 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block8, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block9 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block9, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tc-block0 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tc_block0, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode acm-block (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->acm_block, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode tgm-block1 (T-PFS-BUS-DATA-BLOCK)*/
    if ( !asn1T_PFS_BUS_DATA_BLOCK_Decode(&pVal->tgm_block1, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_BUS_DATA_Initialize(asn1T_PFS_BUS_DATA* pVal)
{

    asn1T_PFS_1BUS_DATA_Initialize(&pVal->pfs_bus1_data);
    asn1T_PFS_1BUS_DATA_Initialize(&pVal->pfs_bus2_data);
    asn1T_PFS_1BUS_DATA_Initialize(&pVal->pfs_bus3_data);
    asn1T_PFS_1BUS_DATA_Initialize(&pVal->pfs_bus4_data);
}


flag asn1T_PFS_BUS_DATA_IsConstraintValid(asn1T_PFS_BUS_DATA* pVal, int* pErrCode)
{
    if ( !asn1T_PFS_1BUS_DATA_IsConstraintValid(&pVal->pfs_bus1_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_1BUS_DATA_IsConstraintValid(&pVal->pfs_bus2_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_1BUS_DATA_IsConstraintValid(&pVal->pfs_bus3_data, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_1BUS_DATA_IsConstraintValid(&pVal->pfs_bus4_data, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_BUS_DATA_Encode(asn1T_PFS_BUS_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_BUS_DATA_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-bus1-data (T-PFS-1BUS-DATA)*/
    asn1T_PFS_1BUS_DATA_Encode(&pVal->pfs_bus1_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-bus2-data (T-PFS-1BUS-DATA)*/
    asn1T_PFS_1BUS_DATA_Encode(&pVal->pfs_bus2_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-bus3-data (T-PFS-1BUS-DATA)*/
    asn1T_PFS_1BUS_DATA_Encode(&pVal->pfs_bus3_data, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-bus4-data (T-PFS-1BUS-DATA)*/
    asn1T_PFS_1BUS_DATA_Encode(&pVal->pfs_bus4_data, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_BUS_DATA_Decode(asn1T_PFS_BUS_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-bus1-data (T-PFS-1BUS-DATA)*/
    if ( !asn1T_PFS_1BUS_DATA_Decode(&pVal->pfs_bus1_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-bus2-data (T-PFS-1BUS-DATA)*/
    if ( !asn1T_PFS_1BUS_DATA_Decode(&pVal->pfs_bus2_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-bus3-data (T-PFS-1BUS-DATA)*/
    if ( !asn1T_PFS_1BUS_DATA_Decode(&pVal->pfs_bus3_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-bus4-data (T-PFS-1BUS-DATA)*/
    if ( !asn1T_PFS_1BUS_DATA_Decode(&pVal->pfs_bus4_data, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_PFS_EWM_DTG12_MSU_Initialize(asn1T_PFS_EWM_DTG12_MSU* pVal)
{

    asn1T_PFS_EWM_DTG_MSU_Initialize(&pVal->pfs_ewm_dtg1_msu);
    asn1T_PFS_EWM_DTG_MSU_Initialize(&pVal->pfs_ewm_dtg2_msu);
}


flag asn1T_PFS_EWM_DTG12_MSU_IsConstraintValid(asn1T_PFS_EWM_DTG12_MSU* pVal, int* pErrCode)
{
    if ( !asn1T_PFS_EWM_DTG_MSU_IsConstraintValid(&pVal->pfs_ewm_dtg1_msu, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_PFS_EWM_DTG_MSU_IsConstraintValid(&pVal->pfs_ewm_dtg2_msu, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_PFS_EWM_DTG12_MSU_Encode(asn1T_PFS_EWM_DTG12_MSU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_PFS_EWM_DTG12_MSU_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode pfs-ewm-dtg1-msu (T-PFS-EWM-DTG-MSU)*/
    asn1T_PFS_EWM_DTG_MSU_Encode(&pVal->pfs_ewm_dtg1_msu, pBitStrm, pErrCode, FALSE);

    /*Encode pfs-ewm-dtg2-msu (T-PFS-EWM-DTG-MSU)*/
    asn1T_PFS_EWM_DTG_MSU_Encode(&pVal->pfs_ewm_dtg2_msu, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_PFS_EWM_DTG12_MSU_Decode(asn1T_PFS_EWM_DTG12_MSU* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode pfs-ewm-dtg1-msu (T-PFS-EWM-DTG-MSU)*/
    if ( !asn1T_PFS_EWM_DTG_MSU_Decode(&pVal->pfs_ewm_dtg1_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-dtg2-msu (T-PFS-EWM-DTG-MSU)*/
    if ( !asn1T_PFS_EWM_DTG_MSU_Decode(&pVal->pfs_ewm_dtg2_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void asn1T_MSU_TELEMETRY_Initialize(asn1T_MSU_TELEMETRY* pVal)
{

    pVal->state_is_pfs_m_stdby = FALSE;
    pVal->state_is_pfs_m_ready_for_cam = FALSE;
    pVal->state_is_pfs_m_cam_in_waiting = FALSE;
    pVal->state_is_pfs_m_cam_prgs = FALSE;
    pVal->state_is_pfs_m_cam_inhib = FALSE;
    pVal->msu_failed_has_been_detected = FALSE;
    asn1T_CAM_MODE_Initialize(&pVal->cam_mode);
    pVal->cam_test2_is_enabled = FALSE;
    pVal->autocam_is_enabled = FALSE;
    pVal->first_config_has_been_received = FALSE;
    asn1T_CONFIGURATION_TABLE_Initialize(&pVal->current_configuration_table);
    asn1T_CONFIGURATION_TABLE_Initialize(&pVal->buffered_configuration_table);
    asn1T_MSU_STATUS_Initialize(&pVal->msu_status);
    pVal->msu_hs_is_ok = FALSE;
    pVal->pfs_iwm_arming_relay_status_on = FALSE;
    asn1T_NAVIGATION_TELEMETRY_Initialize(&pVal->navigation_telemetry);
    asn1T_CONTROLLER_TELEMETRY_Initialize(&pVal->controller_telemetry);
    asn1T_CM_TELEMETRY_Initialize(&pVal->cm_telemetry);
    asn1T_OBUT_Initialize(&pVal->msu_obut);
    asn1T_SYNCHRO_BROADCAST_STATUS_Initialize(&pVal->synchro_broadcast_status);
    asn1T_HW_STATUSES_Initialize(&pVal->hw_statuses);
    asn1T_SW_WARNING_CODE_Initialize(&pVal->sw_warning_code);
    asn1T_FTCP_HEALTH_STATUS_Initialize(&pVal->ftcp_health_status);
    asn1T_INTEGER_Initialize(&pVal->bit_result);
    asn1T_MSU_ID_Initialize(&pVal->msu_id);
    pVal->cm_auto_cam_cmd_is_requested = FALSE;
    pVal->cpu_overload_status = FALSE;
    pVal->pfs_ewm_ssu_msu_is_available = FALSE;
    pVal->controller_to_be_activated = FALSE;
    pVal->msu_online_bit_status_is_ok = FALSE;
    asn1T_PFS_EWM_DTG12_MSU_Initialize(&pVal->pfs_ewm_dtg12_msu);
    pVal->new_config_is_available = FALSE;
    pVal->new_config_is_confirmed = FALSE;
    asn1T_PFS_IWM_MEASUREMENTS_Initialize(&pVal->pfs_iwm_measurements);
    asn1T_POWER_CONSUMPTION_Initialize(&pVal->power_consumption);
}


flag asn1T_MSU_TELEMETRY_IsConstraintValid(asn1T_MSU_TELEMETRY* pVal, int* pErrCode)
{






    if ( !asn1T_CAM_MODE_IsConstraintValid(&pVal->cam_mode, pErrCode) )
    {
        return FALSE;
    }




    if ( !asn1T_CONFIGURATION_TABLE_IsConstraintValid(&pVal->current_configuration_table, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CONFIGURATION_TABLE_IsConstraintValid(&pVal->buffered_configuration_table, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_MSU_STATUS_IsConstraintValid(&pVal->msu_status, pErrCode) )
    {
        return FALSE;
    }



    if ( !asn1T_NAVIGATION_TELEMETRY_IsConstraintValid(&pVal->navigation_telemetry, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CONTROLLER_TELEMETRY_IsConstraintValid(&pVal->controller_telemetry, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_CM_TELEMETRY_IsConstraintValid(&pVal->cm_telemetry, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_OBUT_IsConstraintValid(&pVal->msu_obut, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_SYNCHRO_BROADCAST_STATUS_IsConstraintValid(&pVal->synchro_broadcast_status, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_HW_STATUSES_IsConstraintValid(&pVal->hw_statuses, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_SW_WARNING_CODE_IsConstraintValid(&pVal->sw_warning_code, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_FTCP_HEALTH_STATUS_IsConstraintValid(&pVal->ftcp_health_status, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_INTEGER_IsConstraintValid(&pVal->bit_result, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_MSU_ID_IsConstraintValid(&pVal->msu_id, pErrCode) )
    {
        return FALSE;
    }






    if ( !asn1T_PFS_EWM_DTG12_MSU_IsConstraintValid(&pVal->pfs_ewm_dtg12_msu, pErrCode) )
    {
        return FALSE;
    }



    if ( !asn1T_PFS_IWM_MEASUREMENTS_IsConstraintValid(&pVal->pfs_iwm_measurements, pErrCode) )
    {
        return FALSE;
    }

    if ( !asn1T_POWER_CONSUMPTION_IsConstraintValid(&pVal->power_consumption, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag asn1T_MSU_TELEMETRY_Encode(asn1T_MSU_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !asn1T_MSU_TELEMETRY_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode state-is-pfs-m-stdby (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_stdby);

    /*Encode state-is-pfs-m-ready-for-cam (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_ready_for_cam);

    /*Encode state-is-pfs-m-cam-in-waiting (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_cam_in_waiting);

    /*Encode state-is-pfs-m-cam-prgs (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_cam_prgs);

    /*Encode state-is-pfs-m-cam-inhib (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->state_is_pfs_m_cam_inhib);

    /*Encode msu-failed-has-been-detected (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->msu_failed_has_been_detected);

    /*Encode cam-mode (T-CAM-MODE)*/
    asn1T_CAM_MODE_Encode(&pVal->cam_mode, pBitStrm, pErrCode, FALSE);

    /*Encode cam-test2-is-enabled (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->cam_test2_is_enabled);

    /*Encode autocam-is-enabled (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->autocam_is_enabled);

    /*Encode first-config-has-been-received (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->first_config_has_been_received);

    /*Encode current-configuration-table (T-CONFIGURATION-TABLE)*/
    asn1T_CONFIGURATION_TABLE_Encode(&pVal->current_configuration_table, pBitStrm, pErrCode, FALSE);

    /*Encode buffered-configuration-table (T-CONFIGURATION-TABLE)*/
    asn1T_CONFIGURATION_TABLE_Encode(&pVal->buffered_configuration_table, pBitStrm, pErrCode, FALSE);

    /*Encode msu-status (T-MSU-STATUS)*/
    asn1T_MSU_STATUS_Encode(&pVal->msu_status, pBitStrm, pErrCode, FALSE);

    /*Encode msu-hs-is-ok (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->msu_hs_is_ok);

    /*Encode pfs-iwm-arming-relay-status-on (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_iwm_arming_relay_status_on);

    /*Encode navigation-telemetry (T-NAVIGATION-TELEMETRY)*/
    asn1T_NAVIGATION_TELEMETRY_Encode(&pVal->navigation_telemetry, pBitStrm, pErrCode, FALSE);

    /*Encode controller-telemetry (T-CONTROLLER-TELEMETRY)*/
    asn1T_CONTROLLER_TELEMETRY_Encode(&pVal->controller_telemetry, pBitStrm, pErrCode, FALSE);

    /*Encode cm-telemetry (T-CM-TELEMETRY)*/
    asn1T_CM_TELEMETRY_Encode(&pVal->cm_telemetry, pBitStrm, pErrCode, FALSE);

    /*Encode msu-obut (T-OBUT)*/
    asn1T_OBUT_Encode(&pVal->msu_obut, pBitStrm, pErrCode, FALSE);

    /*Encode synchro-broadcast-status (T-SYNCHRO-BROADCAST-STATUS)*/
    asn1T_SYNCHRO_BROADCAST_STATUS_Encode(&pVal->synchro_broadcast_status, pBitStrm, pErrCode, FALSE);

    /*Encode hw-statuses (T-HW-STATUSES)*/
    asn1T_HW_STATUSES_Encode(&pVal->hw_statuses, pBitStrm, pErrCode, FALSE);

    /*Encode sw-warning-code (T-SW-WARNING-CODE)*/
    asn1T_SW_WARNING_CODE_Encode(&pVal->sw_warning_code, pBitStrm, pErrCode, FALSE);

    /*Encode ftcp-health-status (T-FTCP-HEALTH-STATUS)*/
    asn1T_FTCP_HEALTH_STATUS_Encode(&pVal->ftcp_health_status, pBitStrm, pErrCode, FALSE);

    /*Encode bit-result (T-INTEGER)*/
    asn1T_INTEGER_Encode(&pVal->bit_result, pBitStrm, pErrCode, FALSE);

    /*Encode msu-id (T-MSU-ID)*/
    asn1T_MSU_ID_Encode(&pVal->msu_id, pBitStrm, pErrCode, FALSE);

    /*Encode cm-auto-cam-cmd-is-requested (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->cm_auto_cam_cmd_is_requested);

    /*Encode cpu-overload-status (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->cpu_overload_status);

    /*Encode pfs-ewm-ssu-msu-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->pfs_ewm_ssu_msu_is_available);

    /*Encode controller-to-be-activated (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->controller_to_be_activated);

    /*Encode msu-online-bit-status-is-ok (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->msu_online_bit_status_is_ok);

    /*Encode pfs-ewm-dtg12-msu (T-PFS-EWM-DTG12-MSU)*/
    asn1T_PFS_EWM_DTG12_MSU_Encode(&pVal->pfs_ewm_dtg12_msu, pBitStrm, pErrCode, FALSE);

    /*Encode new-config-is-available (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->new_config_is_available);

    /*Encode new-config-is-confirmed (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->new_config_is_confirmed);

    /*Encode pfs-iwm-measurements (T-PFS-IWM-MEASUREMENTS)*/
    asn1T_PFS_IWM_MEASUREMENTS_Encode(&pVal->pfs_iwm_measurements, pBitStrm, pErrCode, FALSE);

    /*Encode power-consumption (T-POWER-CONSUMPTION)*/
    asn1T_POWER_CONSUMPTION_Encode(&pVal->power_consumption, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag asn1T_MSU_TELEMETRY_Decode(asn1T_MSU_TELEMETRY* pVal, BitStream* pBitStrm, int* pErrCode)
{
        /*Decode state-is-pfs-m-stdby (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_stdby)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-ready-for-cam (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_ready_for_cam)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-cam-in-waiting (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_cam_in_waiting)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-cam-prgs (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_cam_prgs)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode state-is-pfs-m-cam-inhib (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->state_is_pfs_m_cam_inhib)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-failed-has-been-detected (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->msu_failed_has_been_detected)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cam-mode (T-CAM-MODE)*/
    if ( !asn1T_CAM_MODE_Decode(&pVal->cam_mode, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cam-test2-is-enabled (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->cam_test2_is_enabled)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode autocam-is-enabled (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->autocam_is_enabled)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode first-config-has-been-received (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->first_config_has_been_received)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode current-configuration-table (T-CONFIGURATION-TABLE)*/
    if ( !asn1T_CONFIGURATION_TABLE_Decode(&pVal->current_configuration_table, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode buffered-configuration-table (T-CONFIGURATION-TABLE)*/
    if ( !asn1T_CONFIGURATION_TABLE_Decode(&pVal->buffered_configuration_table, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-status (T-MSU-STATUS)*/
    if ( !asn1T_MSU_STATUS_Decode(&pVal->msu_status, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-hs-is-ok (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->msu_hs_is_ok)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-arming-relay-status-on (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_iwm_arming_relay_status_on)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode navigation-telemetry (T-NAVIGATION-TELEMETRY)*/
    if ( !asn1T_NAVIGATION_TELEMETRY_Decode(&pVal->navigation_telemetry, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode controller-telemetry (T-CONTROLLER-TELEMETRY)*/
    if ( !asn1T_CONTROLLER_TELEMETRY_Decode(&pVal->controller_telemetry, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cm-telemetry (T-CM-TELEMETRY)*/
    if ( !asn1T_CM_TELEMETRY_Decode(&pVal->cm_telemetry, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-obut (T-OBUT)*/
    if ( !asn1T_OBUT_Decode(&pVal->msu_obut, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode synchro-broadcast-status (T-SYNCHRO-BROADCAST-STATUS)*/
    if ( !asn1T_SYNCHRO_BROADCAST_STATUS_Decode(&pVal->synchro_broadcast_status, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode hw-statuses (T-HW-STATUSES)*/
    if ( !asn1T_HW_STATUSES_Decode(&pVal->hw_statuses, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode sw-warning-code (T-SW-WARNING-CODE)*/
    if ( !asn1T_SW_WARNING_CODE_Decode(&pVal->sw_warning_code, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode ftcp-health-status (T-FTCP-HEALTH-STATUS)*/
    if ( !asn1T_FTCP_HEALTH_STATUS_Decode(&pVal->ftcp_health_status, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode bit-result (T-INTEGER)*/
    if ( !asn1T_INTEGER_Decode(&pVal->bit_result, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-id (T-MSU-ID)*/
    if ( !asn1T_MSU_ID_Decode(&pVal->msu_id, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cm-auto-cam-cmd-is-requested (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->cm_auto_cam_cmd_is_requested)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode cpu-overload-status (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->cpu_overload_status)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-ssu-msu-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->pfs_ewm_ssu_msu_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode controller-to-be-activated (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->controller_to_be_activated)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode msu-online-bit-status-is-ok (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->msu_online_bit_status_is_ok)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-ewm-dtg12-msu (T-PFS-EWM-DTG12-MSU)*/
    if ( !asn1T_PFS_EWM_DTG12_MSU_Decode(&pVal->pfs_ewm_dtg12_msu, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode new-config-is-available (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->new_config_is_available)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode new-config-is-confirmed (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->new_config_is_confirmed)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode pfs-iwm-measurements (T-PFS-IWM-MEASUREMENTS)*/
    if ( !asn1T_PFS_IWM_MEASUREMENTS_Decode(&pVal->pfs_iwm_measurements, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode power-consumption (T-POWER-CONSUMPTION)*/
    if ( !asn1T_POWER_CONSUMPTION_Decode(&pVal->power_consumption, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


