
/*
Code automatically generated by asn1scc tool
*/
#include <string.h>
#include "sample1.h"
struct {
        long nCount; /*Number of bits in the array. Max value is : 10 */
        byte arr[2];
    } var1 = {
    4,
    {
        0x40
    }
};
struct {
        long nCount; /*Number of bits in the array. Max value is : 10 */
        byte arr[2];
    } var2 = {
    4,
    {
        0x40
    }
};



void MyInt_Initialize(MyInt* pVal)
{

    *pVal = 2;
}


flag MyInt_IsConstraintValid(const MyInt* pVal, int* pErrCode)
{
    if ( !(((*pVal>=2) && (*pVal<=20))) ) {
        *pErrCode = ERR_MyInt;
        return FALSE;
    }
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyInt_Encode(const MyInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 2, 20);
    return TRUE;
}

flag MyInt_Decode(MyInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 2, 20)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyInt2_Initialize(MyInt2* pVal)
{

    *pVal = 5;
}


flag MyInt2_IsConstraintValid(const MyInt2* pVal, int* pErrCode)
{
    if ( !MyInt_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    if ( !(((*pVal>4) && (*pVal<=15))) ) {
        *pErrCode = ERR_MyInt2;
        return FALSE;
    }
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyInt2_Encode(const MyInt2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt2_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 4, 15);
    return TRUE;
}

flag MyInt2_Decode(MyInt2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 4, 15)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyInt3_Initialize(MyInt3* pVal)
{

    *pVal = -9223372036854775808LL;
}


flag MyInt3_IsConstraintValid(const MyInt3* pVal, int* pErrCode)
{
    if ( !(!((*pVal == 4) || (*pVal == 5))) ) {
        *pErrCode = ERR_MyInt3;
        return FALSE;
    }
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyInt3_Encode(const MyInt3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt3_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, *pVal);
    return TRUE;
}

flag MyInt3_Decode(MyInt3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeUnConstraintWholeNumber(pBitStrm, pVal)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyEnum_Initialize(MyEnum* pVal)
{

    *pVal = MyEnum_green;
}


flag MyEnum_IsConstraintValid(const MyEnum* pVal, int* pErrCode)
{
    if ( !(((*pVal == MyEnum_green) || (*pVal == MyEnum_blue))) ) {
        *pErrCode = ERR_MyEnum;
        return FALSE;
    }
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyEnum_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyEnum_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(*pVal)
    {
    case MyEnum_red:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
        break;
    case MyEnum_green:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
        break;
    case MyEnum_blue:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
        break;
    }
    return TRUE;
}

flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint enumIndex = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        *pVal = MyEnum_red;
        break;
    case 1:
        *pVal = MyEnum_green;
        break;
    case 2:
        *pVal = MyEnum_blue;
        break;
    }
    return TRUE;
}


void MyEnum2_Initialize(MyEnum2* pVal)
{

    *pVal = MyEnum2_red;
}


flag MyEnum2_IsConstraintValid(const MyEnum2* pVal, int* pErrCode)
{
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyEnum2_Encode(const MyEnum2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyEnum2_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(*pVal)
    {
    case MyEnum2_red:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
        break;
    case MyEnum2_green:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
        break;
    case MyEnum2_blue:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
        break;
    }
    return TRUE;
}

flag MyEnum2_Decode(MyEnum2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint enumIndex = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        *pVal = MyEnum2_red;
        break;
    case 1:
        *pVal = MyEnum2_green;
        break;
    case 2:
        *pVal = MyEnum2_blue;
        break;
    }
    return TRUE;
}


void MyStruct_Initialize(MyStruct* pVal)
{

    pVal->a = 10;
    pVal->b = 15;
    pVal->c = MyEnum_blue;
    pVal->d.nCount = 4;
    memcpy(pVal->d.arr,var1.arr,1);
}


flag MyStruct_IsConstraintValid(const MyStruct* pVal, int* pErrCode)
{
    if ( !MyInt2_IsConstraintValid(&pVal->a, pErrCode) )
    {
        return FALSE;
    }
    if ( !(((pVal->a>=10) && (pVal->a<=15))) ) {
        *pErrCode = ERR_MyStruct_a;
        return FALSE;
    }

    if ( pVal->exist.b ) {
        if ( !MyInt2_IsConstraintValid(&pVal->b, pErrCode) )
        {
            return FALSE;
        }
    }

    if ( pVal->exist.c ) {
        if ( !MyEnum_IsConstraintValid(&pVal->c, pErrCode) )
        {
            return FALSE;
        }
    }

    if ( pVal->exist.d ) {
        if ( !(((pVal->d.nCount>=1) && (pVal->d.nCount<=10)) && ( (pVal->d.nCount == var2.nCount) && !memcmp(pVal->d.arr, var2.arr, 1) )) ) {
            *pErrCode = ERR_MyStruct_d;
            return FALSE;
        }
    }

    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyStruct_Encode(const MyStruct* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !MyStruct_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* Encode Bit Mask for optional and default fields*/
    BitStream_AppendBit(pBitStrm, pVal->exist.b);
    BitStream_AppendBit(pBitStrm, pVal->exist.c);
    BitStream_AppendBit(pBitStrm, pVal->exist.d);

    /*Encode a (MyInt2)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->a, 10, 15);

    /*Encode b (MyInt2)*/
    if ( pVal->exist.b ) {
        MyInt2_Encode(&pVal->b, pBitStrm, pErrCode, FALSE);
    }

    /*Encode c (MyEnum)*/
    if ( pVal->exist.c ) {
        MyEnum_Encode(&pVal->c, pBitStrm, pErrCode, FALSE);
    }

    /*Encode d (BIT STRING)*/
    if ( pVal->exist.d ) {
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->d.nCount, 1, 10);
        BitStream_AppendBits(pBitStrm, pVal->d.arr, pVal->d.nCount);
    }

    return TRUE;
}

flag MyStruct_Decode(MyStruct* pVal, BitStream* pBitStrm, int* pErrCode)
{
    byte bitMask[1];
    asn1SccSint enumIndex = 0;
    asn1SccSint nCount = 0;
    int i1 = 0;

    if (!BitStream_ReadBits(pBitStrm, bitMask, 3)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode a (MyInt2)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->a, 10, 15)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode b (MyInt2)*/
    pVal->exist.b = 0;
    if ((bitMask[0] & 0x80) != 0 ) {
        pVal->exist.b = 1;
        if ( !MyInt2_Decode(&pVal->b, pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    else
    {
        pVal->exist.b = 1;
        pVal->b = 15;
    }
    /*Decode c (MyEnum)*/
    pVal->exist.c = 0;
    if ((bitMask[0] & 0x40) != 0 ) {
        pVal->exist.c = 1;
        if ( !MyEnum_Decode(&pVal->c, pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    else
    {
        pVal->exist.c = 1;
        pVal->c = MyEnum_blue;
    }
    /*Decode d (BIT STRING)*/
    pVal->exist.d = 0;
    if ((bitMask[0] & 0x20) != 0 ) {
        pVal->exist.d = 1;
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 10)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        pVal->d.nCount = (long)nCount;
        if (!BitStream_ReadBits(pBitStrm, pVal->d.arr, pVal->d.nCount)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    else
    {
        pVal->exist.d = 1;
        pVal->d.nCount = 4;
        memcpy(pVal->d.arr,var1.arr,1);
    }
    return TRUE;
}

