
/*
Code automatically generated by asn1cc tool
*/
#include <string.h>
#include <assert.h>
#include "sample1.h"

void MyOct_Initialize(MyOct* pVal)
{

    pVal->nCount = 0;
    memset(pVal->arr,0x0,4);
}


flag MyOct_IsConstraintValid(MyOct* pVal, int* pErrCode)
{
    if ( !(pVal->nCount == 4) ) {
        *pErrCode = ERR_MyOct;
        return FALSE;
    }
    return TRUE;
}

flag MyOct_Encode(MyOct* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyOct_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeOctetString(pBitStrm, pVal->arr, pVal->nCount);
    return TRUE;
}

flag MyOct_Decode(MyOct* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void MyBit_Initialize(MyBit* pVal)
{

    pVal->nCount = 0;
    memset(pVal->arr,0x0,3);
}


flag MyBit_IsConstraintValid(MyBit* pVal, int* pErrCode)
{
    if ( !(pVal->nCount == 20) ) {
        *pErrCode = ERR_MyBit;
        return FALSE;
    }
    return TRUE;
}

flag MyBit_Encode(MyBit* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyBit_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeBitString(pBitStrm, pVal->arr, pVal->nCount);
    return TRUE;
}

flag MyBit_Decode(MyBit* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void MyNull_Initialize(MyNull* pVal)
{

    *pVal = 0;
}


flag MyNull_IsConstraintValid(MyNull* pVal, int* pErrCode)
{
    return TRUE;
}

flag MyNull_Encode(MyNull* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyNull_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    return TRUE;
}

flag MyNull_Decode(MyNull* pVal, BitStream* pBitStrm, int* pErrCode)
{
    return TRUE;
}


void MyTestPDU_Initialize(MyTestPDU* pVal)
{

    *pVal = 0;
}


flag MyTestPDU_IsConstraintValid(MyTestPDU* pVal, int* pErrCode)
{
    if ( !((*pVal == 1) || (*pVal == 2) || (*pVal == 3)) ) {
        *pErrCode = ERR_MyTestPDU;
        return FALSE;
    }
    return TRUE;
}

flag MyTestPDU_Encode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyTestPDU_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 1, 3);
    return TRUE;
}

flag MyTestPDU_Decode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 1, 3)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyInt2_Initialize(MyInt2* pVal)
{

    *pVal = 0;
}


flag MyInt2_IsConstraintValid(MyInt2* pVal, int* pErrCode)
{
    if ( !((*pVal>=10) && (*pVal<=100)) ) {
        *pErrCode = ERR_MyInt2;
        return FALSE;
    }
    return TRUE;
}

flag MyInt2_Encode(MyInt2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt2_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 10, 100);
    return TRUE;
}

flag MyInt2_Decode(MyInt2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 10, 100)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyInt2b_Initialize(MyInt2b* pVal)
{

    *pVal = 0;
}


flag MyInt2b_IsConstraintValid(MyInt2b* pVal, int* pErrCode)
{
    if ( !(((*pVal>=10) && (*pVal<=100)) || ((*pVal>=200) && (*pVal<500))) ) {
        *pErrCode = ERR_MyInt2b;
        return FALSE;
    }
    return TRUE;
}

flag MyInt2b_Encode(MyInt2b* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt2b_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 10, 500);
    return TRUE;
}

flag MyInt2b_Decode(MyInt2b* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 10, 500)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyInt3_Initialize(MyInt3* pVal)
{

    *pVal = 0;
}


flag MyInt3_IsConstraintValid(MyInt3* pVal, int* pErrCode)
{
    if ( !(*pVal<=100) ) {
        *pErrCode = ERR_MyInt3;
        return FALSE;
    }
    return TRUE;
}

flag MyInt3_Encode(MyInt3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt3_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, *pVal);
    return TRUE;
}

flag MyInt3_Decode(MyInt3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeUnConstraintWholeNumber(pBitStrm, pVal)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyInt4_Initialize(MyInt4* pVal)
{

    *pVal = 0;
}


flag MyInt4_IsConstraintValid(MyInt4* pVal, int* pErrCode)
{
    if ( !(*pVal>=20) ) {
        *pErrCode = ERR_MyInt4;
        return FALSE;
    }
    return TRUE;
}

flag MyInt4_Encode(MyInt4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt4_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeSemiConstraintWholeNumber(pBitStrm, *pVal, 20);
    return TRUE;
}

flag MyInt4_Decode(MyInt4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeSemiConstraintWholeNumber(pBitStrm, pVal, 20)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyReal_Initialize(MyReal* pVal)
{

    *pVal = 0;
}


flag MyReal_IsConstraintValid(MyReal* pVal, int* pErrCode)
{
    return TRUE;
}

flag MyReal_Encode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyReal_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeReal(pBitStrm, *pVal);
    return TRUE;
}

flag MyReal_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeReal(pBitStrm, pVal)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyEnum_Initialize(MyEnum* pVal)
{

    *pVal = alpha;
}


flag MyEnum_IsConstraintValid(MyEnum* pVal, int* pErrCode)
{
    return TRUE;
}

flag MyEnum_Encode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyEnum_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(*pVal)
    {
    case alpha:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
        break;
    case beta:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
        break;
    case gamma:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
        break;
    }
    return TRUE;
}

flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void MyString_Initialize(MyString pVal)
{

    memset(pVal, 0x0, 11);
}

flag CheckString1(const char* str)
{
    size_t i;
    size_t n = strlen(str);
    for(i=0;i<n;i++)
    {
        if (!(((str[i]>='A') && (str[i]<='Z')) || strchr("abcde", str[i])))
            return FALSE;
    }
    return TRUE;
}

flag MyString_IsConstraintValid(MyString pVal, int* pErrCode)
{
    if ( !((strlen(pVal)>=1) && (strlen(pVal)<=10)) && CheckString1(pVal) ) {
        *pErrCode = ERR_MyString;
        return FALSE;
    }
    return TRUE;
}

flag MyString_Encode(MyString pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyString_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    {
        static IntegerRange ir1 = { 1, FALSE, TRUE, 10, FALSE, TRUE };
        static CharSet cs = { 31, {0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
                                    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,0x63,0x64,
                                    0x65} };
        BitStream_EncodeIA5String(pBitStrm, pVal, &ir1, FALSE, NULL, &cs);
    }
    return TRUE;
}

flag MyString_Decode(MyString pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void MyBool_Initialize(MyBool* pVal)
{

    *pVal = FALSE;
}


flag MyBool_IsConstraintValid(MyBool* pVal, int* pErrCode)
{
    return TRUE;
}

flag MyBool_Encode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyBool_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_AppendBit(pBitStrm, *pVal);
    return TRUE;
}

flag MyBool_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void MyStruct_Initialize(MyStruct* pVal)
{

    int i1 = 0;
    int i2 = 0;

    pVal->mitsos.nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        pVal->mitsos.arr[i1].nCount = 0;
        for(i2=0;i2<5;i2++)
        {
            pVal->mitsos.arr[i1].arr[i2] = 0;
        }
    }
    pVal->a1 = 0;
    pVal->b1 = 0;
    MyEnum_Initialize(&pVal->c);
}


flag MyStruct_IsConstraintValid(MyStruct* pVal, int* pErrCode)
{
    if ( !((pVal->mitsos.nCount>=1) && (pVal->mitsos.nCount<=4)) ) {
        *pErrCode = ERR_MyStruct_mitsos;
        return FALSE;
    }


    {
        int i1;
        for(i1=0;i1<pVal->mitsos.nCount;i1++)
        {
            if ( !((pVal->mitsos.arr[i1].nCount>=1) && (pVal->mitsos.arr[i1].nCount<=5)) ) {
                *pErrCode = ERR_MyStruct_mitsos_elem;
                return FALSE;
            }


            {
                int i3;
                for(i3=0;i3<pVal->mitsos.arr[i1].nCount;i3++)
                {
                    if ( !((pVal->mitsos.arr[i1].arr[i3]>=1) && (pVal->mitsos.arr[i1].arr[i3]<=1000)) ) {
                        *pErrCode = ERR_MyStruct_mitsos_elem_elem;
                        return FALSE;
                    }
                }
            }

        }
    }


    if ( !((pVal->a1>=1) && (pVal->a1<=10)) ) {
        *pErrCode = ERR_MyStruct_a1;
        return FALSE;
    }


    if ( !MyEnum_IsConstraintValid(&pVal->c, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag MyStruct_Encode(MyStruct* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyStruct_IsConstraintValid(pVal, pErrCode))
        return FALSE;


    {
        int i1;

        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->mitsos.nCount, 1, 4);
        for(i1=0;i1<pVal->mitsos.nCount;i1++)
        {
            {
                int i3;

                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->mitsos.arr[i1].nCount, 1, 5);
                for(i3=0;i3<pVal->mitsos.arr[i1].nCount;i3++)
                {
                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->mitsos.arr[i1].arr[i3], 1, 1000);
                }
            }

        }
    }


    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->a1, 1, 10);

    BitStream_EncodeReal(pBitStrm, pVal->b1);

    MyEnum_Encode(&pVal->c, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag MyStruct_Decode(MyStruct* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
                assert(0);

        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->a1, 1, 10)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        if (!BitStream_DecodeReal(pBitStrm, &pVal->b1)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        assert(0);

    }
    return TRUE;
}


void MyStruct2_Initialize(MyStruct2* pVal)
{

    pVal->a2 = 0;
    pVal->b2 = 0;
    MyEnum_Initialize(&pVal->c2);
}


flag MyStruct2_IsConstraintValid(MyStruct2* pVal, int* pErrCode)
{
    if ( !((pVal->a2>=1) && (pVal->a2<=10)) ) {
        *pErrCode = ERR_MyStruct2_a2;
        return FALSE;
    }


    if ( !MyEnum_IsConstraintValid(&pVal->c2, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag MyStruct2_Encode(MyStruct2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyStruct2_IsConstraintValid(pVal, pErrCode))
        return FALSE;


    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->a2, 1, 10);

    BitStream_EncodeReal(pBitStrm, pVal->b2);

    MyEnum_Encode(&pVal->c2, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag MyStruct2_Decode(MyStruct2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
                if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->a2, 1, 10)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        if (!BitStream_DecodeReal(pBitStrm, &pVal->b2)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        assert(0);

    }
    return TRUE;
}


void MyChoice_Initialize(MyChoice* pVal)
{

    pVal->kind = MyChoice_NONE;
}


flag MyChoice_IsConstraintValid(MyChoice* pVal, int* pErrCode)
{
    switch(pVal->kind)
    {
    case alpha_PRESENT:
        if ( !MyStruct_IsConstraintValid(&pVal->u.alpha, pErrCode) )
        {
            return FALSE;
        }
        break;
    case beta_PRESENT:
        if ( !MyStruct2_IsConstraintValid(&pVal->u.beta, pErrCode) )
        {
            return FALSE;
        }
        break;
    case octStr_PRESENT:
        if ( !(pVal->u.octStr.nCount == 4) ) {
            *pErrCode = ERR_MyChoice_octStr;
            return FALSE;
        }
        break;
    default:
        *pErrCode = ERR_MyChoice;
        return FALSE;
    }
    return TRUE;
}

flag MyChoice_Encode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyChoice_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(pVal->kind)
    {
    case alpha_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
        MyStruct_Encode(&pVal->u.alpha, pBitStrm, pErrCode, FALSE);
        break;
    case beta_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
        MyStruct2_Encode(&pVal->u.beta, pBitStrm, pErrCode, FALSE);
        break;
    case octStr_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
        BitStream_EncodeOctetString(pBitStrm, pVal->u.octStr.arr, pVal->u.octStr.nCount);
        break;
    }
    return TRUE;
}

flag MyChoice_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void Engine_Initialize(Engine* pVal)
{

    pVal->horsePower = 0;
    pVal->fuelConsumption = 0;
    pVal->co2Emissions = 0;
}


flag Engine_IsConstraintValid(Engine* pVal, int* pErrCode)
{
    if ( !((pVal->horsePower>=0) && (pVal->horsePower<=1001)) ) {
        *pErrCode = ERR_Engine_horsePower;
        return FALSE;
    }


    if ( !((pVal->co2Emissions>=0) && (pVal->co2Emissions<=300)) ) {
        *pErrCode = ERR_Engine_co2Emissions;
        return FALSE;
    }

    return TRUE;
}

flag Engine_Encode(Engine* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !Engine_IsConstraintValid(pVal, pErrCode))
        return FALSE;


    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->horsePower, 0, 1001);

    BitStream_EncodeReal(pBitStrm, pVal->fuelConsumption);

    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->co2Emissions, 0, 300);

    return TRUE;
}

flag Engine_Decode(Engine* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
                if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->horsePower, 0, 1001)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        if (!BitStream_DecodeReal(pBitStrm, &pVal->fuelConsumption)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->co2Emissions, 0, 300)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

    }
    return TRUE;
}


void Wheel_Initialize(Wheel* pVal)
{

    pVal->radius = 0;
    pVal->tread = 0;
}


flag Wheel_IsConstraintValid(Wheel* pVal, int* pErrCode)
{
    if ( !((pVal->radius>=5) && (pVal->radius<=40)) ) {
        *pErrCode = ERR_Wheel_radius;
        return FALSE;
    }

    if ( !((pVal->tread>=2) && (pVal->tread<=25)) ) {
        *pErrCode = ERR_Wheel_tread;
        return FALSE;
    }

    return TRUE;
}

flag Wheel_Encode(Wheel* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !Wheel_IsConstraintValid(pVal, pErrCode))
        return FALSE;


    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->radius, 5, 40);

    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->tread, 2, 25);

    return TRUE;
}

flag Wheel_Decode(Wheel* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
                if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->radius, 5, 40)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->tread, 2, 25)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }

    }
    return TRUE;
}


void SportEquipment_Initialize(SportEquipment* pVal)
{

    pVal->aircondition = FALSE;
    pVal->leatherSofas = FALSE;
    pVal->xenonLights = FALSE;
}


flag SportEquipment_IsConstraintValid(SportEquipment* pVal, int* pErrCode)
{



    return TRUE;
}

flag SportEquipment_Encode(SportEquipment* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !SportEquipment_IsConstraintValid(pVal, pErrCode))
        return FALSE;


    BitStream_AppendBit(pBitStrm, pVal->aircondition);

    BitStream_AppendBit(pBitStrm, pVal->leatherSofas);

    BitStream_AppendBit(pBitStrm, pVal->xenonLights);

    return TRUE;
}

flag SportEquipment_Decode(SportEquipment* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
                assert(0);

        assert(0);

        assert(0);

    }
    return TRUE;
}


void ClassicEquipment_Initialize(ClassicEquipment* pVal)
{

    pVal->aircondition = FALSE;
    pVal->leatherSofas = FALSE;
}


flag ClassicEquipment_IsConstraintValid(ClassicEquipment* pVal, int* pErrCode)
{


    return TRUE;
}

flag ClassicEquipment_Encode(ClassicEquipment* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !ClassicEquipment_IsConstraintValid(pVal, pErrCode))
        return FALSE;


    BitStream_AppendBit(pBitStrm, pVal->aircondition);

    BitStream_AppendBit(pBitStrm, pVal->leatherSofas);

    return TRUE;
}

flag ClassicEquipment_Decode(ClassicEquipment* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
                assert(0);

        assert(0);

    }
    return TRUE;
}


void ExtraEquipment_Initialize(ExtraEquipment* pVal)
{

    pVal->kind = ExtraEquipment_NONE;
}


flag ExtraEquipment_IsConstraintValid(ExtraEquipment* pVal, int* pErrCode)
{
    switch(pVal->kind)
    {
    case ExtraEquipment_sport_PRESENT:
        if ( !SportEquipment_IsConstraintValid(&pVal->u.sport, pErrCode) )
        {
            return FALSE;
        }
        break;
    case ExtraEquipment_classic_PRESENT:
        if ( !ClassicEquipment_IsConstraintValid(&pVal->u.classic, pErrCode) )
        {
            return FALSE;
        }
        break;
    default:
        *pErrCode = ERR_ExtraEquipment;
        return FALSE;
    }
    return TRUE;
}

flag ExtraEquipment_Encode(ExtraEquipment* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !ExtraEquipment_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(pVal->kind)
    {
    case ExtraEquipment_sport_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
        SportEquipment_Encode(&pVal->u.sport, pBitStrm, pErrCode, FALSE);
        break;
    case ExtraEquipment_classic_PRESENT:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
        ClassicEquipment_Encode(&pVal->u.classic, pBitStrm, pErrCode, FALSE);
        break;
    }
    return TRUE;
}

flag ExtraEquipment_Decode(ExtraEquipment* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


void Vehicle_Initialize(Vehicle* pVal)
{

    int i1 = 0;
    int i2 = 0;

    MyString_Initialize(pVal->myStr);
    Engine_Initialize(&pVal->engine);
    pVal->wheels.nCount = 0;
    for(i1=0;i1<4;i1++)
    {
        Wheel_Initialize(&pVal->wheels.arr[i1]);
    }
    pVal->color = color_red;
    pVal->color2 = color2_red;
    strcpy(pVal->serialNumber, "0000000000");
    ExtraEquipment_Initialize(&pVal->extraEquipment);
    pVal->internal1.radius = 0;
    pVal->internal1.tread = 0;
    pVal->internal1.internal2.radius = 0;
    pVal->internal1.internal2.tread = 0;
    pVal->internal1.internal2.intArray.nCount = 0;
    for(i1=0;i1<10;i1++)
    {
        pVal->internal1.internal2.intArray.arr[i1] = 0;
    }
    pVal->internal1.internal2.intDoubleArray.nCount = 0;
    for(i1=0;i1<10;i1++)
    {
        pVal->internal1.internal2.intDoubleArray.arr[i1].nCount = 0;
        for(i2=0;i2<100;i2++)
        {
            pVal->internal1.internal2.intDoubleArray.arr[i1].arr[i2] = 0;
        }
    }
    pVal->internal1.internal2.intArryStruct.nCount = 0;
    for(i1=0;i1<10;i1++)
    {
        pVal->internal1.internal2.intArryStruct.arr[i1].nCount = 0;
        for(i2=0;i2<100;i2++)
        {
            pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].alpha = 0;
            pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].beta = 0;
            pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].color2 = orange;
            pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].octstr.nCount = 0;
            memset(pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].octstr.arr,0x0,50);
            pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].bitstr.nCount = 0;
            memset(pVal->internal1.internal2.intArryStruct.arr[i1].arr[i2].bitstr.arr,0x0,3);
        }
    }
    pVal->internalChoiceA.nCount = 0;
    for(i1=0;i1<20;i1++)
    {
        pVal->internalChoiceA.arr[i1].nCount = 0;
        for(i2=0;i2<9;i2++)
        {
            pVal->internalChoiceA.arr[i1].arr[i2].kind = internalChoiceA_arr_NONE;
        }
    }
}

flag CheckString2(const char* str)
{
    size_t i;
    size_t n = strlen(str);
    for(i=0;i<n;i++)
    {
        if (!strchr("ABC", str[i]))
            return FALSE;
    }
    return TRUE;
}

flag Vehicle_IsConstraintValid(Vehicle* pVal, int* pErrCode)
{
    if ( !MyString_IsConstraintValid(pVal->myStr, pErrCode) )
    {
        return FALSE;
    }
    if ( !((strlen(pVal->myStr)>=2) && (strlen(pVal->myStr)<=6)) && CheckString2(pVal->myStr) ) {
        *pErrCode = ERR_Vehicle_myStr;
        return FALSE;
    }

    if ( !Engine_IsConstraintValid(&pVal->engine, pErrCode) )
    {
        return FALSE;
    }

    if ( !((pVal->wheels.nCount>=2) && (pVal->wheels.nCount<=4)) ) {
        *pErrCode = ERR_Vehicle_wheels;
        return FALSE;
    }


    {
        int i1;
        for(i1=0;i1<pVal->wheels.nCount;i1++)
        {
            if ( !Wheel_IsConstraintValid(&pVal->wheels.arr[i1], pErrCode) )
            {
                return FALSE;
            }
        }
    }


    if ( !((pVal->color == color_red) || (pVal->color == color_blue)) ) {
        *pErrCode = ERR_Vehicle_color;
        return FALSE;
    }

    if ( !((pVal->color2 == color2_red) || (pVal->color2 == Vehicle_color2_blue)) ) {
        *pErrCode = ERR_Vehicle_color2;
        return FALSE;
    }

    if ( !((strlen(pVal->serialNumber)>=1) && (strlen(pVal->serialNumber)<=10)) ) {
        *pErrCode = ERR_Vehicle_serialNumber;
        return FALSE;
    }

    if ( !ExtraEquipment_IsConstraintValid(&pVal->extraEquipment, pErrCode) )
    {
        return FALSE;
    }

    if ( !((pVal->internal1.radius>=5) && (pVal->internal1.radius<=40)) ) {
        *pErrCode = ERR_Vehicle_internal1_radius;
        return FALSE;
    }

    if ( !((pVal->internal1.tread>=2) && (pVal->internal1.tread<=25)) ) {
        *pErrCode = ERR_Vehicle_internal1_tread;
        return FALSE;
    }

    if ( !((pVal->internal1.internal2.radius>=5) && (pVal->internal1.internal2.radius<=40)) ) {
        *pErrCode = ERR_Vehicle_internal1_internal2_radius;
        return FALSE;
    }

    if ( !((pVal->internal1.internal2.tread>=2) && (pVal->internal1.internal2.tread<=25)) ) {
        *pErrCode = ERR_Vehicle_internal1_internal2_tread;
        return FALSE;
    }

    if ( !(pVal->internal1.internal2.intArray.nCount == 10) ) {
        *pErrCode = ERR_Vehicle_internal1_internal2_intArray;
        return FALSE;
    }


    {
        int i1;
        for(i1=0;i1<pVal->internal1.internal2.intArray.nCount;i1++)
        {
            if ( !((pVal->internal1.internal2.intArray.arr[i1]>=1) && (pVal->internal1.internal2.intArray.arr[i1]<=5)) ) {
                *pErrCode = ERR_Vehicle_internal1_internal2_intArray_elem;
                return FALSE;
            }
        }
    }


    if ( !(pVal->internal1.internal2.intDoubleArray.nCount == 10) ) {
        *pErrCode = ERR_Vehicle_internal1_internal2_intDoubleArray;
        return FALSE;
    }


    {
        int i1;
        for(i1=0;i1<pVal->internal1.internal2.intDoubleArray.nCount;i1++)
        {
            if ( !(pVal->internal1.internal2.intDoubleArray.arr[i1].nCount == 100) ) {
                *pErrCode = ERR_Vehicle_internal1_internal2_intDoubleArray_elem;
                return FALSE;
            }


            {
                int i3;
                for(i3=0;i3<pVal->internal1.internal2.intDoubleArray.arr[i1].nCount;i3++)
                {
                    if ( !((pVal->internal1.internal2.intDoubleArray.arr[i1].arr[i3]>=1) && (pVal->internal1.internal2.intDoubleArray.arr[i1].arr[i3]<=5)) ) {
                        *pErrCode = ERR_Vehicle_internal1_internal2_intDoubleArray_elem_elem;
                        return FALSE;
                    }
                }
            }

        }
    }


    if ( !(pVal->internal1.internal2.intArryStruct.nCount == 10) ) {
        *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct;
        return FALSE;
    }


    {
        int i1;
        for(i1=0;i1<pVal->internal1.internal2.intArryStruct.nCount;i1++)
        {
            if ( !(pVal->internal1.internal2.intArryStruct.arr[i1].nCount == 100) ) {
                *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct_elem;
                return FALSE;
            }


            {
                int i3;
                for(i3=0;i3<pVal->internal1.internal2.intArryStruct.arr[i1].nCount;i3++)
                {
                    if ( !((pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].alpha>=5) && (pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].alpha<=40)) ) {
                        *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct_elem_elem_alpha;
                        return FALSE;
                    }

                    if ( !((pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].beta>=2) && (pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].beta<=25)) ) {
                        *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct_elem_elem_beta;
                        return FALSE;
                    }

                    if ( !((pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].color2 == orange) || (pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].color2 == arr_color2_blue)) ) {
                        *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct_elem_elem_color2;
                        return FALSE;
                    }

                    if ( !(((pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].octstr.nCount>=1) && (pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].octstr.nCount<=20)) || (pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].octstr.nCount == 50)) ) {
                        *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct_elem_elem_octstr;
                        return FALSE;
                    }

                    if ( !((pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].bitstr.nCount>=5) && (pVal->internal1.internal2.intArryStruct.arr[i1].arr[i3].bitstr.nCount<=20)) ) {
                        *pErrCode = ERR_Vehicle_internal1_internal2_intArryStruct_elem_elem_bitstr;
                        return FALSE;
                    }

                }
            }

        }
    }




    if ( !(pVal->internalChoiceA.nCount == 20) ) {
        *pErrCode = ERR_Vehicle_internalChoiceA;
        return FALSE;
    }


    {
        int i1;
        for(i1=0;i1<pVal->internalChoiceA.nCount;i1++)
        {
            if ( !(pVal->internalChoiceA.arr[i1].nCount == 9) ) {
                *pErrCode = ERR_Vehicle_internalChoiceA_elem;
                return FALSE;
            }


            {
                int i3;
                for(i3=0;i3<pVal->internalChoiceA.arr[i1].nCount;i3++)
                {
                    switch(pVal->internalChoiceA.arr[i1].arr[i3].kind)
                    {
                    case internalChoiceA_arr_sport_PRESENT:
                        if ( !SportEquipment_IsConstraintValid(&pVal->internalChoiceA.arr[i1].arr[i3].u.sport, pErrCode) )
                        {
                            return FALSE;
                        }
                        break;
                    case internalChoiceA_arr_classic_PRESENT:
                        if ( !ClassicEquipment_IsConstraintValid(&pVal->internalChoiceA.arr[i1].arr[i3].u.classic, pErrCode) )
                        {
                            return FALSE;
                        }
                        break;
                    case internalChoiceB_PRESENT:
                        if ( !(pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.nCount == 20) ) {
                            *pErrCode = ERR_Vehicle_internalChoiceA_elem_elem_internalChoiceB;
                            return FALSE;
                        }


                        {
                            int i6;
                            for(i6=0;i6<pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.nCount;i6++)
                            {
                                if ( !(pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].nCount == 9) ) {
                                    *pErrCode = ERR_Vehicle_internalChoiceA_elem_elem_internalChoiceB_elem;
                                    return FALSE;
                                }


                                {
                                    int i8;
                                    for(i8=0;i8<pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].nCount;i8++)
                                    {
                                        switch(pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].kind)
                                        {
                                        case internalChoiceB_arr_sport_PRESENT:
                                            if ( !SportEquipment_IsConstraintValid(&pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.sport, pErrCode) )
                                            {
                                                return FALSE;
                                            }
                                            break;
                                        case internalChoiceB_arr_classic_PRESENT:
                                            if ( !ClassicEquipment_IsConstraintValid(&pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.classic, pErrCode) )
                                            {
                                                return FALSE;
                                            }
                                            break;
                                        case octstr_PRESENT:
                                            if ( !(((pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.octstr.nCount>=1) && (pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.octstr.nCount<=20)) || (pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.octstr.nCount == 50)) ) {
                                                *pErrCode = ERR_Vehicle_internalChoiceA_elem_elem_internalChoiceB_elem_elem_octstr;
                                                return FALSE;
                                            }
                                            break;
                                        default:
                                            *pErrCode = ERR_Vehicle_internalChoiceA_elem_elem_internalChoiceB_elem_elem;
                                            return FALSE;
                                        }
                                    }
                                }

                            }
                        }

                        break;
                    default:
                        *pErrCode = ERR_Vehicle_internalChoiceA_elem_elem;
                        return FALSE;
                    }
                }
            }

        }
    }


    return TRUE;
}

flag Vehicle_Encode(Vehicle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !Vehicle_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    /* Encode Bit Mask for optional and default fields*/
    BitStream_AppendBit(pBitStrm, pVal->exist.color);
    BitStream_AppendBit(pBitStrm, pVal->exist.color2);
    BitStream_AppendBit(pBitStrm, pVal->exist.serialNumber);
    BitStream_AppendBit(pBitStrm, pVal->exist.extraEquipment);


    MyString_Encode(pVal->myStr, pBitStrm, pErrCode, FALSE);

    Engine_Encode(&pVal->engine, pBitStrm, pErrCode, FALSE);

    {
        int i1;

        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->wheels.nCount, 2, 4);
        for(i1=0;i1<pVal->wheels.nCount;i1++)
        {
            Wheel_Encode(&pVal->wheels.arr[i1], pBitStrm, pErrCode, FALSE);
        }
    }


    if ( pVal->exist.color )
        switch(pVal->color)
        {
        case color_red:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
            break;
        case color_green:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
            break;
        case color_blue:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
            break;
        case color_black:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
            break;
        }

    if ( pVal->exist.color2 )
        switch(pVal->color2)
        {
        case color2_red:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
            break;
        case color2_green:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
            break;
        case Vehicle_color2_blue:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
            break;
        case Vehicle_color2_black:
            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
            break;
        }

    if ( pVal->exist.serialNumber )
        {
            static IntegerRange ir1 = { 1, FALSE, TRUE, 10, FALSE, TRUE };
            BitStream_EncodeIA5String(pBitStrm, pVal->serialNumber, &ir1, FALSE, NULL, NULL);
        }

    if ( pVal->exist.extraEquipment )
        ExtraEquipment_Encode(&pVal->extraEquipment, pBitStrm, pErrCode, FALSE);

    /* Encode Bit Mask for optional and default fields*/
    BitStream_AppendBit(pBitStrm, pVal->internal1.exist.radius);
    BitStream_AppendBit(pBitStrm, pVal->internal1.exist.internal2);


    if ( pVal->internal1.exist.radius )
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.radius, 5, 40);

    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.tread, 2, 25);

    if ( pVal->internal1.exist.internal2 )
        /* Encode Bit Mask for optional and default fields*/
        BitStream_AppendBit(pBitStrm, pVal->internal1.internal2.exist.radius);


        if ( pVal->internal1.internal2.exist.radius )
            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.internal2.radius, 5, 40);

        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.internal2.tread, 2, 25);

        {
            int i2;

            /* No need to encode length (it is fixed size (10)*/
            for(i2=0;i2<pVal->internal1.internal2.intArray.nCount;i2++)
            {
                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.internal2.intArray.arr[i2], 1, 5);
            }
        }


        {
            int i2;

            /* No need to encode length (it is fixed size (10)*/
            for(i2=0;i2<pVal->internal1.internal2.intDoubleArray.nCount;i2++)
            {
                {
                    int i4;

                    /* No need to encode length (it is fixed size (100)*/
                    for(i4=0;i4<pVal->internal1.internal2.intDoubleArray.arr[i2].nCount;i4++)
                    {
                        BitStream_EncodeReal(pBitStrm, pVal->internal1.internal2.intDoubleArray.arr[i2].arr[i4]);
                    }
                }

            }
        }


        {
            int i2;

            /* No need to encode length (it is fixed size (10)*/
            for(i2=0;i2<pVal->internal1.internal2.intArryStruct.nCount;i2++)
            {
                {
                    int i4;

                    /* No need to encode length (it is fixed size (100)*/
                    for(i4=0;i4<pVal->internal1.internal2.intArryStruct.arr[i2].nCount;i4++)
                    {
                        /* Encode Bit Mask for optional and default fields*/
                        BitStream_AppendBit(pBitStrm, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].exist.alpha);
                        BitStream_AppendBit(pBitStrm, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].exist.color2);


                        if ( pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].exist.alpha )
                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].alpha, 5, 40);

                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].beta, 2, 25);

                        if ( pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].exist.color2 )
                            switch(pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].color2)
                            {
                            case orange:
                                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
                                break;
                            case brown:
                                BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
                                break;
                            case arr_color2_blue:
                                BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
                                break;
                            case arr_color2_black:
                                BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
                                break;
                            }

                        BitStream_EncodeOctetString(pBitStrm, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].octstr.arr, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].octstr.nCount);

                        BitStream_EncodeBitString(pBitStrm, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].bitstr.arr, pVal->internal1.internal2.intArryStruct.arr[i2].arr[i4].bitstr.nCount);

                    }
                }

            }
        }




    {
        int i1;

        /* No need to encode length (it is fixed size (20)*/
        for(i1=0;i1<pVal->internalChoiceA.nCount;i1++)
        {
            {
                int i3;

                /* No need to encode length (it is fixed size (9)*/
                for(i3=0;i3<pVal->internalChoiceA.arr[i1].nCount;i3++)
                {
                    switch(pVal->internalChoiceA.arr[i1].arr[i3].kind)
                    {
                    case internalChoiceA_arr_sport_PRESENT:
                        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
                        SportEquipment_Encode(&pVal->internalChoiceA.arr[i1].arr[i3].u.sport, pBitStrm, pErrCode, FALSE);
                        break;
                    case internalChoiceA_arr_classic_PRESENT:
                        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
                        ClassicEquipment_Encode(&pVal->internalChoiceA.arr[i1].arr[i3].u.classic, pBitStrm, pErrCode, FALSE);
                        break;
                    case internalChoiceB_PRESENT:
                        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
                        {
                            int i6;

                            /* No need to encode length (it is fixed size (20)*/
                            for(i6=0;i6<pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.nCount;i6++)
                            {
                                {
                                    int i8;

                                    /* No need to encode length (it is fixed size (9)*/
                                    for(i8=0;i8<pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].nCount;i8++)
                                    {
                                        switch(pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].kind)
                                        {
                                        case internalChoiceB_arr_sport_PRESENT:
                                            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
                                            SportEquipment_Encode(&pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.sport, pBitStrm, pErrCode, FALSE);
                                            break;
                                        case internalChoiceB_arr_classic_PRESENT:
                                            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
                                            ClassicEquipment_Encode(&pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.classic, pBitStrm, pErrCode, FALSE);
                                            break;
                                        case octstr_PRESENT:
                                            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
                                            BitStream_EncodeOctetString(pBitStrm, pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.octstr.arr, pVal->internalChoiceA.arr[i1].arr[i3].u.internalChoiceB.arr[i6].arr[i8].u.octstr.nCount);
                                            break;
                                        }
                                    }
                                }

                            }
                        }

                        break;
                    }
                }
            }

        }
    }


    return TRUE;
}

flag Vehicle_Decode(Vehicle* pVal, BitStream* pBitStrm, int* pErrCode)
{
    {
        byte bitMask[1];
        if (!BitStream_ReadBits(pBitStrm, bitMask, 4))
            return FALSE;
        assert(0);

        assert(0);

        assert(0);

        if (bitMask[0] & 0x80)
            assert(0);

        if (bitMask[0] & 0x40)
            assert(0);

        if (bitMask[0] & 0x20)
            assert(0);

        if (bitMask[0] & 0x10)
            assert(0);

        {
            byte bitMask[1];
            if (!BitStream_ReadBits(pBitStrm, bitMask, 2))
                return FALSE;
            if (bitMask[0] & 0x80)
                if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->internal1.radius, 5, 40)) {
                    *pErrCode = ERR_INSUFFICIENT_DATA;
                    return FALSE;
                }

            if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->internal1.tread, 2, 25)) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }

            if (bitMask[0] & 0x40)
                {
                    byte bitMask[1];
                    if (!BitStream_ReadBits(pBitStrm, bitMask, 1))
                        return FALSE;
                    if (bitMask[0] & 0x80)
                        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->internal1.internal2.radius, 5, 40)) {
                            *pErrCode = ERR_INSUFFICIENT_DATA;
                            return FALSE;
                        }

                    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->internal1.internal2.tread, 2, 25)) {
                        *pErrCode = ERR_INSUFFICIENT_DATA;
                        return FALSE;
                    }

                    assert(0);

                    assert(0);

                    assert(0);

                }

        }

        assert(0);

    }
    return TRUE;
}


void DayProduction_Initialize(DayProduction* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<500;i1++)
    {
        Vehicle_Initialize(&pVal->arr[i1]);
    }
}


flag DayProduction_IsConstraintValid(DayProduction* pVal, int* pErrCode)
{
    int i1;
    if ( !(pVal->nCount == 500) ) {
        *pErrCode = ERR_DayProduction;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !Vehicle_IsConstraintValid(&pVal->arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

flag DayProduction_Encode(DayProduction* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !DayProduction_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    {
        int i1;

        /* No need to encode length (it is fixed size (500)*/
        for(i1=0;i1<pVal->nCount;i1++)
        {
            Vehicle_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
        }
    }

    return TRUE;
}

flag DayProduction_Decode(DayProduction* pVal, BitStream* pBitStrm, int* pErrCode)
{
    assert(0);
    return TRUE;
}


MyOct mOct = {
    4,
    {
        0xAB,
        0xCF,
        0xEF,
        0x01
    }
};
MyTestPDU testPDU = 1;
MyReal ar = 3.14;
MyEnum myEnum = alpha;
MyString str = "ABCDE";
MyBool myBool = TRUE;
