
/*
Code automatically generated by asn1cc tool
*/
#include <string.h>
#include "sample1.h"

void MyTestPDU_Initialize(MyTestPDU* pVal)
{

    pVal->int1 = 0;
    pVal->int2 = 0;
    pVal->enm = MyTestPDU_enm_one;
    pVal->buf.nCount = 0;
    memset(pVal->buf.arr,0x0,10);
    pVal->gg.int1 = 0;
    pVal->gg.int2 = 0;
    pVal->gg.enm = gg_enm_one;
    pVal->gg.buf.nCount = 0;
    memset(pVal->gg.buf.arr,0x0,10);
}


flag MyTestPDU_IsConstraintValid(MyTestPDU* pVal, int* pErrCode)
{
    if ( !(((pVal->int1>=0) && (pVal->int1<=15))) ) {
        *pErrCode = ERR_MyTestPDU_int1;
        return FALSE;
    }

    if ( !(((pVal->int2>=0) && (pVal->int2<=65535))) ) {
        *pErrCode = ERR_MyTestPDU_int2;
        return FALSE;
    }


    if ( !((pVal->buf.nCount == 10)) ) {
        *pErrCode = ERR_MyTestPDU_buf;
        return FALSE;
    }

    if ( !(((pVal->gg.int1>=0) && (pVal->gg.int1<=15))) ) {
        *pErrCode = ERR_MyTestPDU_gg_int1;
        return FALSE;
    }

    if ( !(((pVal->gg.int2>=0) && (pVal->gg.int2<=65535))) ) {
        *pErrCode = ERR_MyTestPDU_gg_int2;
        return FALSE;
    }


    if ( !((pVal->gg.buf.nCount == 10)) ) {
        *pErrCode = ERR_MyTestPDU_gg_buf;
        return FALSE;
    }


    return TRUE;
}

flag MyTestPDU_Encode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !MyTestPDU_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode int1 (INTEGER)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->int1, 0, 15);

    /*Encode int2 (INTEGER)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->int2, 0, 65535);

    /*Encode enm (ENUMERATED)*/
    switch(pVal->enm)
    {
    case MyTestPDU_enm_one:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
        break;
    case MyTestPDU_enm_two:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
        break;
    case MyTestPDU_enm_three:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
        break;
    case MyTestPDU_enm_four:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
        break;
    case MyTestPDU_enm_thousand:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
        break;
    }

    /*Encode buf (OCTET STRING)*/
    /* No need to encode length (it is fixed size (10)*/
    for(i1=0;i1<pVal->buf.nCount;i1++)
    {
        BitStream_AppendByte0(pBitStrm, pVal->buf.arr[i1]);
    }

    /*Encode gg (SEQUENCE)*/

    /*Encode int1 (INTEGER)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->gg.int1, 0, 15);

    /*Encode int2 (INTEGER)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->gg.int2, 0, 65535);

    /*Encode enm (ENUMERATED)*/
    switch(pVal->gg.enm)
    {
    case gg_enm_one:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
        break;
    case gg_enm_two:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
        break;
    case gg_enm_three:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
        break;
    case gg_enm_four:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
        break;
    case gg_enm_thousand:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
        break;
    }

    /*Encode buf (OCTET STRING)*/
    /* No need to encode length (it is fixed size (10)*/
    for(i1=0;i1<pVal->gg.buf.nCount;i1++)
    {
        BitStream_AppendByte0(pBitStrm, pVal->gg.buf.arr[i1]);
    }


    return TRUE;
}

flag MyTestPDU_Decode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint enumIndex = 0;
    asn1SccSint nCount = 0;
    int i1 = 0;

        /*Decode int1 (INTEGER)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->int1, 0, 15)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode int2 (INTEGER)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->int2, 0, 65535)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode enm (ENUMERATED)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        pVal->enm = MyTestPDU_enm_one;
        break;
    case 1:
        pVal->enm = MyTestPDU_enm_two;
        break;
    case 2:
        pVal->enm = MyTestPDU_enm_three;
        break;
    case 3:
        pVal->enm = MyTestPDU_enm_four;
        break;
    case 4:
        pVal->enm = MyTestPDU_enm_thousand;
        break;
    }
    /*Decode buf (OCTET STRING)*/
    pVal->buf.nCount = 10;
    for(i1=0;i1<pVal->buf.nCount;i1++)
    {
        if ( !BitStream_ReadByte(pBitStrm, &pVal->buf.arr[i1]) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode gg (SEQUENCE)*/
        /*Decode int1 (INTEGER)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->gg.int1, 0, 15)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode int2 (INTEGER)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->gg.int2, 0, 65535)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode enm (ENUMERATED)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        pVal->gg.enm = gg_enm_one;
        break;
    case 1:
        pVal->gg.enm = gg_enm_two;
        break;
    case 2:
        pVal->gg.enm = gg_enm_three;
        break;
    case 3:
        pVal->gg.enm = gg_enm_four;
        break;
    case 4:
        pVal->gg.enm = gg_enm_thousand;
        break;
    }
    /*Decode buf (OCTET STRING)*/
    pVal->gg.buf.nCount = 10;
    for(i1=0;i1<pVal->gg.buf.nCount;i1++)
    {
        if ( !BitStream_ReadByte(pBitStrm, &pVal->gg.buf.arr[i1]) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void MyInt_Initialize(MyInt* pVal)
{

    *pVal = 0;
}


flag MyInt_IsConstraintValid(MyInt* pVal, int* pErrCode)
{
    return TRUE;
}

flag MyInt_Encode(MyInt* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !MyInt_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, *pVal);
    return TRUE;
}

flag MyInt_Decode(MyInt* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeUnConstraintWholeNumber(pBitStrm, pVal)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


MyTestPDU testPDU = {
    .int1 = 10,
    .int2 = 200,
    .enm = MyTestPDU_enm_one,
    .buf = {
        10,
        {
            0x00,
            0x11,
            0x22,
            0x33,
            0x44,
            0x55,
            0x66,
            0x77,
            0x88,
            0x99
        }
    },
    .gg = {
        .int1 = 10,
        .int2 = 200,
        .enm = gg_enm_one,
        .buf = {
            10,
            {
                0x00,
                0x11,
                0x22,
                0x33,
                0x44,
                0x55,
                0x66,
                0x77,
                0x88,
                0x99
            }
        }
    }
};
