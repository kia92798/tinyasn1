
/*
Code automatically generated by asn1scc tool
*/
#include <string.h>
#include "sample1.h"
struct {
        long nCount;
        byte arr[3];
    } var1 = {
    3,
    {
        0xCC,
        0xFF,
        0xDD
    }
};
struct {
        long nCount;
        byte arr[3];
    } var2 = {
    3,
    {
        0xCC,
        0xFF,
        0xDD
    }
};

void MyType_Initialize(MyType* pVal)
{

    int i1 = 0;
    int i2 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<100;i1++)
    {
        pVal->arr[i1].a = 0;
        pVal->arr[i1].a1.nCount = 0;
        for(i2=0;i2<10;i2++)
        {
            pVal->arr[i1].a1.arr[i2] = 0;
        }
        pVal->arr[i1].b = TRUE;
        pVal->arr[i1].c = 0;
        pVal->arr[i1].d.nCount = 3;
        memcpy(pVal->arr[i1].d.arr,var1.arr,3);
    }
}


flag MyType_IsConstraintValid(MyType* pVal, int* pErrCode)
{
    int i1 = 0;
    int i2 = 0;

    if ( !(((pVal->nCount>=1) && (pVal->nCount<=100))) ) {
        *pErrCode = ERR_MyType;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !(((pVal->arr[i1].a>=1) && (pVal->arr[i1].a<=20)) && (pVal->arr[i1].a == 12)) ) {
            *pErrCode = ERR_MyType_elem_a;
            return FALSE;
        }

        if ( !(((pVal->arr[i1].a1.nCount>=1) && (pVal->arr[i1].a1.nCount<=10))) ) {
            *pErrCode = ERR_MyType_elem_a1;
            return FALSE;
        }

        for(i2=0;i2<pVal->arr[i1].a1.nCount;i2++)
        {
            if ( !(((pVal->arr[i1].a1.arr[i2]>=1) && (pVal->arr[i1].a1.arr[i2]<=10))) ) {
                *pErrCode = ERR_MyType_elem_a1_elem;
                return FALSE;
            }
        }

        if ( pVal->arr[i1].exist.b ) {
        }

        if ( pVal->arr[i1].exist.c ) {
            if ( !(((pVal->arr[i1].c>=0) && (pVal->arr[i1].c<=7))) ) {
                *pErrCode = ERR_MyType_elem_c;
                return FALSE;
            }
        }

        if ( pVal->arr[i1].exist.d ) {
            if ( !((pVal->arr[i1].d.nCount == 3)) ) {
                *pErrCode = ERR_MyType_elem_d;
                return FALSE;
            }
        }

    }
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag MyType_Encode(MyType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;
    int i2 = 0;

    if (bCheckConstraints && !MyType_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 100);
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (SEQUENCE)*/
        /* Encode Bit Mask for optional and default fields*/
        BitStream_AppendBit(pBitStrm, pVal->arr[i1].exist.b);
        BitStream_AppendBit(pBitStrm, pVal->arr[i1].exist.c);
        BitStream_AppendBit(pBitStrm, pVal->arr[i1].exist.d);

        /*Encode a (INTEGER)*/
        /* No need to encode value since it will always be 12*/

        /*Encode a1 (SEQUENCE OF)*/
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].a1.nCount, 1, 10);
        for(i2=0;i2<pVal->arr[i1].a1.nCount;i2++)
        {
            /*Encode childlen : (INTEGER)*/
            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].a1.arr[i2], 1, 10);
        }

        /*Encode b (BOOLEAN)*/
        if ( pVal->arr[i1].exist.b ) {
            BitStream_AppendBit(pBitStrm, pVal->arr[i1].b);
        }

        /*Encode c (INTEGER)*/
        if ( pVal->arr[i1].exist.c ) {
            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].c, 0, 7);
        }

        /*Encode d (OCTET STRING)*/
        if ( pVal->arr[i1].exist.d ) {
            /* No need to encode length (it is fixed size (3)*/
            for(i2=0;i2<pVal->arr[i1].d.nCount;i2++)
            {
                BitStream_AppendByte0(pBitStrm, pVal->arr[i1].d.arr[i2]);
            }
        }

    }
    return TRUE;
}

flag MyType_Decode(MyType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nCount = 0;
    int i1 = 0;
    byte bitMask[1];
    int i2 = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 100)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->nCount = (long)nCount;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (SEQUENCE)*/
        if (!BitStream_ReadBits(pBitStrm, bitMask, 3)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        /*Decode a (INTEGER)*/
        pVal->arr[i1].a = 12;
        /*Decode a1 (SEQUENCE OF)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 10)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        pVal->arr[i1].a1.nCount = (long)nCount;
        for(i2=0;i2<pVal->arr[i1].a1.nCount;i2++)
        {
            /*Decode childlen : (INTEGER)*/
            if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->arr[i1].a1.arr[i2], 1, 10)) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        /*Decode b (BOOLEAN)*/
        pVal->arr[i1].exist.b = 0;
        if ((bitMask[0] & 0x80) != 0 ) {
            pVal->arr[i1].exist.b = 1;
            if (!BitStream_ReadBit(pBitStrm, &pVal->arr[i1].b)) { 
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        else
        {
            pVal->arr[i1].exist.b = 1;
            pVal->arr[i1].b = TRUE;
        }
        /*Decode c (INTEGER)*/
        pVal->arr[i1].exist.c = 0;
        if ((bitMask[0] & 0x40) != 0 ) {
            pVal->arr[i1].exist.c = 1;
            if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->arr[i1].c, 0, 7)) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        /*Decode d (OCTET STRING)*/
        pVal->arr[i1].exist.d = 0;
        if ((bitMask[0] & 0x20) != 0 ) {
            pVal->arr[i1].exist.d = 1;
            pVal->arr[i1].d.nCount = 3;
            for(i2=0;i2<pVal->arr[i1].d.nCount;i2++)
            {
                if ( !BitStream_ReadByte(pBitStrm, &pVal->arr[i1].d.arr[i2]) ) {
                    *pErrCode = ERR_INSUFFICIENT_DATA;
                    return FALSE;
                }
            }
        }
        else
        {
            pVal->arr[i1].exist.d = 1;
            pVal->arr[i1].d.nCount = 3;
            memcpy(pVal->arr[i1].d.arr,var1.arr,3);
        }
    }
    return TRUE;
}


void MyTestPDU_Initialize(MyTestPDU* pVal)
{

    int i1 = 0;
    int i2 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<100;i1++)
    {
        pVal->arr[i1].a = 0;
        pVal->arr[i1].a1.nCount = 0;
        for(i2=0;i2<10;i2++)
        {
            pVal->arr[i1].a1.arr[i2] = 0;
        }
        pVal->arr[i1].b = TRUE;
        pVal->arr[i1].c = 0;
        pVal->arr[i1].d.nCount = 3;
        memcpy(pVal->arr[i1].d.arr,var1.arr,3);
    }
}

flag WithComponentAux1(MyTestPDU* pVal);

flag MyTestPDU_IsConstraintValid(MyTestPDU* pVal, int* pErrCode)
{
    int i1 = 0;
    int i2 = 0;

    if ( !MyType_IsConstraintValid(pVal, pErrCode) )
    {
        return FALSE;
    }
    if ( !(WithComponentAux1(pVal)) ) {
        *pErrCode = ERR_MyTestPDU;
        return FALSE;
    }
    (void)pVal; /*Dummy statement, just to hide potential warning*/
    (void)pErrCode; /*Dummy statement, just to hide potential warning*/
    return TRUE;
}

flag WithComponentAux1(MyTestPDU* pVal)
{
    size_t i;
    size_t n = pVal->nCount;
    for(i=0;i<n;i++)
    {
        if (!pVal->arr[i].exist.c && (pVal->arr[i].a1.nCount == 5) && (pVal->arr[i].c == 3) && ( (pVal->arr[i].d.nCount == var2.nCount) && !memcmp(pVal->arr[i].d.arr, var2.arr, var2.nCount) ))
            return FALSE;
    }
    return TRUE;
}
flag MyTestPDU_Encode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;
    int i2 = 0;

    if (bCheckConstraints && !MyTestPDU_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 100);
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (SEQUENCE)*/
        /* Encode Bit Mask for optional and default fields*/
        BitStream_AppendBit(pBitStrm, pVal->arr[i1].exist.b);
        BitStream_AppendBit(pBitStrm, pVal->arr[i1].exist.c);
        BitStream_AppendBit(pBitStrm, pVal->arr[i1].exist.d);

        /*Encode a (INTEGER)*/
        /* No need to encode value since it will always be 12*/

        /*Encode a1 (SEQUENCE OF)*/
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].a1.nCount, 1, 10);
        for(i2=0;i2<pVal->arr[i1].a1.nCount;i2++)
        {
            /*Encode childlen : (INTEGER)*/
            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].a1.arr[i2], 1, 10);
        }

        /*Encode b (BOOLEAN)*/
        if ( pVal->arr[i1].exist.b ) {
            BitStream_AppendBit(pBitStrm, pVal->arr[i1].b);
        }

        /*Encode c (INTEGER)*/
        if ( pVal->arr[i1].exist.c ) {
            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].c, 0, 7);
        }

        /*Encode d (OCTET STRING)*/
        if ( pVal->arr[i1].exist.d ) {
            /* No need to encode length (it is fixed size (3)*/
            for(i2=0;i2<pVal->arr[i1].d.nCount;i2++)
            {
                BitStream_AppendByte0(pBitStrm, pVal->arr[i1].d.arr[i2]);
            }
        }

    }
    return TRUE;
}

flag MyTestPDU_Decode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nCount = 0;
    int i1 = 0;
    byte bitMask[1];
    int i2 = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 100)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->nCount = (long)nCount;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (SEQUENCE)*/
        if (!BitStream_ReadBits(pBitStrm, bitMask, 3)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        /*Decode a (INTEGER)*/
        pVal->arr[i1].a = 12;
        /*Decode a1 (SEQUENCE OF)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 10)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
        pVal->arr[i1].a1.nCount = (long)nCount;
        for(i2=0;i2<pVal->arr[i1].a1.nCount;i2++)
        {
            /*Decode childlen : (INTEGER)*/
            if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->arr[i1].a1.arr[i2], 1, 10)) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        /*Decode b (BOOLEAN)*/
        pVal->arr[i1].exist.b = 0;
        if ((bitMask[0] & 0x80) != 0 ) {
            pVal->arr[i1].exist.b = 1;
            if (!BitStream_ReadBit(pBitStrm, &pVal->arr[i1].b)) { 
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        else
        {
            pVal->arr[i1].exist.b = 1;
            pVal->arr[i1].b = TRUE;
        }
        /*Decode c (INTEGER)*/
        pVal->arr[i1].exist.c = 0;
        if ((bitMask[0] & 0x40) != 0 ) {
            pVal->arr[i1].exist.c = 1;
            if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->arr[i1].c, 0, 7)) {
                *pErrCode = ERR_INSUFFICIENT_DATA;
                return FALSE;
            }
        }
        /*Decode d (OCTET STRING)*/
        pVal->arr[i1].exist.d = 0;
        if ((bitMask[0] & 0x20) != 0 ) {
            pVal->arr[i1].exist.d = 1;
            pVal->arr[i1].d.nCount = 3;
            for(i2=0;i2<pVal->arr[i1].d.nCount;i2++)
            {
                if ( !BitStream_ReadByte(pBitStrm, &pVal->arr[i1].d.arr[i2]) ) {
                    *pErrCode = ERR_INSUFFICIENT_DATA;
                    return FALSE;
                }
            }
        }
        else
        {
            pVal->arr[i1].exist.d = 1;
            pVal->arr[i1].d.nCount = 3;
            memcpy(pVal->arr[i1].d.arr,var1.arr,3);
        }
    }
    return TRUE;
}


asn1SccSint  aa = 12;
/*
MyTestPDU testPDU = {
    6,
    {
        {
            .a = 5,
            .a1 = {
                5,
                {
                    1,
                    2,
                    3,
                    4,
                    5
                }
            },
            .b = TRUE,
            .c = 3,
            .d = {
                3,
                {
                    0xCC,
                    0xFF,
                    0xDD
                }
            },
            .exist = {
                .b = 1,
                .c = 1,
                .d = 1
            }
        },
        {
            .a = 5,
            .a1 = {
                5,
                {
                    1,
                    2,
                    3,
                    4,
                    5
                }
            },
            .b = TRUE,
            .c = 3,
            .d = {
                3,
                {
                    0xCC,
                    0xFF,
                    0xDD
                }
            },
            .exist = {
                .b = 1,
                .c = 1,
                .d = 1
            }
        },
        {
            .a = 5,
            .a1 = {
                5,
                {
                    1,
                    2,
                    3,
                    4,
                    5
                }
            },
            .b = TRUE,
            .c = 3,
            .d = {
                3,
                {
                    0xCC,
                    0xFF,
                    0xDD
                }
            },
            .exist = {
                .b = 1,
                .c = 1,
                .d = 1
            }
        },
        {
            .a = 5,
            .a1 = {
                5,
                {
                    1,
                    2,
                    3,
                    4,
                    5
                }
            },
            .b = TRUE,
            .c = 3,
            .d = {
                3,
                {
                    0xCC,
                    0xFF,
                    0xDD
                }
            },
            .exist = {
                .b = 1,
                .c = 1,
                .d = 1
            }
        },
        {
            .a = 5,
            .a1 = {
                5,
                {
                    1,
                    2,
                    3,
                    4,
                    5
                }
            },
            .b = TRUE,
            .c = 3,
            .d = {
                3,
                {
                    0xCC,
                    0xFF,
                    0xDD
                }
            },
            .exist = {
                .b = 1,
                .c = 1,
                .d = 1
            }
        },
        {
            .a = 5,
            .a1 = {
                5,
                {
                    1,
                    2,
                    3,
                    4,
                    5
                }
            },
            .b = TRUE,
            .c = 3,
            .d = {
                3,
                {
                    0xCC,
                    0xFF,
                    0xDD
                }
            },
            .exist = {
                .b = 1,
                .c = 1,
                .d = 1
            }
        }
    }
};
*/