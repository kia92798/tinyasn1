
/*
Code automatically generated by asn1cc tool
*/
#include <string.h>
#include "sample1.h"

void TypeEnumerated_Initialize(TypeEnumerated* pVal)
{

    *pVal = red;
}


flag TypeEnumerated_IsConstraintValid(TypeEnumerated* pVal, int* pErrCode)
{
    return TRUE;
}

flag TypeEnumerated_Encode(TypeEnumerated* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !TypeEnumerated_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    switch(*pVal)
    {
    case red:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
        break;
    case green:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
        break;
    case blue:
        BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
        break;
    }
    return TRUE;
}

flag TypeEnumerated_Decode(TypeEnumerated* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint enumIndex = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    switch(enumIndex)
    {
    case 0:
        *pVal = red;
        break;
    case 1:
        *pVal = green;
        break;
    case 2:
        *pVal = blue;
        break;
    }
    return TRUE;
}


void T_POS2_Initialize(T_POS2* pVal)
{

    *pVal = FALSE;
}


flag T_POS2_IsConstraintValid(T_POS2* pVal, int* pErrCode)
{
    return TRUE;
}

flag T_POS2_Encode(T_POS2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !T_POS2_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_AppendBit(pBitStrm, *pVal);
    return TRUE;
}

flag T_POS2_Decode(T_POS2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_ReadBit(pBitStrm, pVal)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void T_ARR_Initialize(T_ARR* pVal)
{

    int i1 = 0;

    pVal->nCount = 0;
    for(i1=0;i1<6;i1++)
    {
        pVal->arr[i1] = 0;
    }
}


flag T_ARR_IsConstraintValid(T_ARR* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !(((pVal->nCount>=5) && (pVal->nCount<=6))) ) {
        *pErrCode = ERR_T_ARR;
        return FALSE;
    }

    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !(((pVal->arr[i1]>=0) && (pVal->arr[i1]<=4))) ) {
            *pErrCode = ERR_T_ARR_elem;
            return FALSE;
        }
    }
    return TRUE;
}

flag T_ARR_Encode(T_ARR* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !T_ARR_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 5, 6);
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Encode childlen : (INTEGER)*/
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1], 0, 4);
    }
    return TRUE;
}

flag T_ARR_Decode(T_ARR* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nCount = 0;
    int i1 = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 5, 6)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->nCount = (long)nCount;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        /*Decode childlen : (INTEGER)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->arr[i1], 0, 4)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void T_BOOL_Initialize(T_BOOL* pVal)
{

    *pVal = FALSE;
}


flag T_BOOL_IsConstraintValid(T_BOOL* pVal, int* pErrCode)
{
    return TRUE;
}

flag T_BOOL_Encode(T_BOOL* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !T_BOOL_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_AppendBit(pBitStrm, *pVal);
    return TRUE;
}

flag T_BOOL_Decode(T_BOOL* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_ReadBit(pBitStrm, pVal)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void T_INT_Initialize(T_INT* pVal)
{

    *pVal = 0;
}


flag T_INT_IsConstraintValid(T_INT* pVal, int* pErrCode)
{
    if ( !(((*pVal>=0) && (*pVal<=50))) ) {
        *pErrCode = ERR_T_INT;
        return FALSE;
    }
    return TRUE;
}

flag T_INT_Encode(T_INT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !T_INT_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 50);
    return TRUE;
}

flag T_INT_Decode(T_INT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 50)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void T_REAL_Initialize(T_REAL* pVal)
{

    *pVal = 0;
}


flag T_REAL_IsConstraintValid(T_REAL* pVal, int* pErrCode)
{
    if ( !(((*pVal>=-3.14) && (*pVal<=3.14))) ) {
        *pErrCode = ERR_T_REAL;
        return FALSE;
    }
    return TRUE;
}

flag T_REAL_Encode(T_REAL* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    if (bCheckConstraints && !T_REAL_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeReal(pBitStrm, *pVal);
    return TRUE;
}

flag T_REAL_Decode(T_REAL* pVal, BitStream* pBitStrm, int* pErrCode)
{
    if (!BitStream_DecodeReal(pBitStrm, pVal)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void T_STRING_Initialize(T_STRING* pVal)
{

    pVal->nCount = 0;
    memset(pVal->arr,0x0,15);
}


flag T_STRING_IsConstraintValid(T_STRING* pVal, int* pErrCode)
{
    if ( !(((pVal->nCount>=1) && (pVal->nCount<=15))) ) {
        *pErrCode = ERR_T_STRING;
        return FALSE;
    }
    return TRUE;
}

flag T_STRING_Encode(T_STRING* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !T_STRING_IsConstraintValid(pVal, pErrCode))
        return FALSE;
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 15);
    for(i1=0;i1<pVal->nCount;i1++)
    {
        BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
    }
    return TRUE;
}

flag T_STRING_Decode(T_STRING* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nCount = 0;
    int i1 = 0;

    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 15)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->nCount = (long)nCount;
    for(i1=0;i1<pVal->nCount;i1++)
    {
        if ( !BitStream_ReadByte(pBitStrm, &pVal->arr[i1]) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


void TypeNested_Initialize(TypeNested* pVal)
{

    int i1 = 0;

    pVal->intVal = 0;
    pVal->intArray.nCount = 0;
    for(i1=0;i1<10;i1++)
    {
        pVal->intArray.arr[i1] = 0;
    }
    pVal->boolArray.nCount = 0;
    for(i1=0;i1<10;i1++)
    {
        T_BOOL_Initialize(&pVal->boolArray.arr[i1]);
    }
    TypeEnumerated_Initialize(&pVal->enumValue);
    pVal->label.nCount = 0;
    memset(pVal->label.arr,0x0,40);
    T_BOOL_Initialize(&pVal->bAlpha);
    pVal->bBeta = FALSE;
    T_STRING_Initialize(&pVal->sString);
    T_ARR_Initialize(&pVal->arr);
}


flag TypeNested_IsConstraintValid(TypeNested* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !(((pVal->intVal>=0) && (pVal->intVal<=10))) ) {
        *pErrCode = ERR_TypeNested_intVal;
        return FALSE;
    }

    if ( !(((pVal->intArray.nCount>=2) && (pVal->intArray.nCount<=10))) ) {
        *pErrCode = ERR_TypeNested_intArray;
        return FALSE;
    }

    for(i1=0;i1<pVal->intArray.nCount;i1++)
    {
        if ( !(((pVal->intArray.arr[i1]>=0) && (pVal->intArray.arr[i1]<=3))) ) {
            *pErrCode = ERR_TypeNested_intArray_elem;
            return FALSE;
        }
    }

    if ( !(((pVal->boolArray.nCount>=2) && (pVal->boolArray.nCount<=10))) ) {
        *pErrCode = ERR_TypeNested_boolArray;
        return FALSE;
    }

    for(i1=0;i1<pVal->boolArray.nCount;i1++)
    {
        if ( !T_BOOL_IsConstraintValid(&pVal->boolArray.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    if ( !TypeEnumerated_IsConstraintValid(&pVal->enumValue, pErrCode) )
    {
        return FALSE;
    }

    if ( !(((pVal->label.nCount>=2) && (pVal->label.nCount<=40))) ) {
        *pErrCode = ERR_TypeNested_label;
        return FALSE;
    }

    if ( !T_BOOL_IsConstraintValid(&pVal->bAlpha, pErrCode) )
    {
        return FALSE;
    }


    if ( !T_STRING_IsConstraintValid(&pVal->sString, pErrCode) )
    {
        return FALSE;
    }

    if ( !T_ARR_IsConstraintValid(&pVal->arr, pErrCode) )
    {
        return FALSE;
    }

    return TRUE;
}

flag TypeNested_Encode(TypeNested* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;

    if (bCheckConstraints && !TypeNested_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode intVal (INTEGER)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->intVal, 0, 10);

    /*Encode intArray (SEQUENCE OF)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->intArray.nCount, 2, 10);
    for(i1=0;i1<pVal->intArray.nCount;i1++)
    {
        /*Encode childlen : (INTEGER)*/
        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->intArray.arr[i1], 0, 3);
    }

    /*Encode boolArray (SEQUENCE OF)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->boolArray.nCount, 2, 10);
    for(i1=0;i1<pVal->boolArray.nCount;i1++)
    {
        /*Encode childlen : (T-BOOL)*/
        T_BOOL_Encode(&pVal->boolArray.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    /*Encode enumValue (TypeEnumerated)*/
    TypeEnumerated_Encode(&pVal->enumValue, pBitStrm, pErrCode, FALSE);

    /*Encode label (OCTET STRING)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->label.nCount, 2, 40);
    for(i1=0;i1<pVal->label.nCount;i1++)
    {
        BitStream_AppendByte0(pBitStrm, pVal->label.arr[i1]);
    }

    /*Encode bAlpha (T-BOOL)*/
    T_BOOL_Encode(&pVal->bAlpha, pBitStrm, pErrCode, FALSE);

    /*Encode bBeta (BOOLEAN)*/
    BitStream_AppendBit(pBitStrm, pVal->bBeta);

    /*Encode sString (T-STRING)*/
    T_STRING_Encode(&pVal->sString, pBitStrm, pErrCode, FALSE);

    /*Encode arr (T-ARR)*/
    T_ARR_Encode(&pVal->arr, pBitStrm, pErrCode, FALSE);

    return TRUE;
}

flag TypeNested_Decode(TypeNested* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nCount = 0;
    int i1 = 0;
    asn1SccSint enumIndex = 0;

        /*Decode intVal (INTEGER)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->intVal, 0, 10)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode intArray (SEQUENCE OF)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 2, 10)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->intArray.nCount = (long)nCount;
    for(i1=0;i1<pVal->intArray.nCount;i1++)
    {
        /*Decode childlen : (INTEGER)*/
        if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &pVal->intArray.arr[i1], 0, 3)) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode boolArray (SEQUENCE OF)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 2, 10)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->boolArray.nCount = (long)nCount;
    for(i1=0;i1<pVal->boolArray.nCount;i1++)
    {
        /*Decode childlen : (T-BOOL)*/
        if ( !T_BOOL_Decode(&pVal->boolArray.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode enumValue (TypeEnumerated)*/
    if ( !TypeEnumerated_Decode(&pVal->enumValue, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode label (OCTET STRING)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 2, 40)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->label.nCount = (long)nCount;
    for(i1=0;i1<pVal->label.nCount;i1++)
    {
        if ( !BitStream_ReadByte(pBitStrm, &pVal->label.arr[i1]) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    /*Decode bAlpha (T-BOOL)*/
    if ( !T_BOOL_Decode(&pVal->bAlpha, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode bBeta (BOOLEAN)*/
    if (!BitStream_ReadBit(pBitStrm, &pVal->bBeta)) { 
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode sString (T-STRING)*/
    if ( !T_STRING_Decode(&pVal->sString, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode arr (T-ARR)*/
    if ( !T_ARR_Decode(&pVal->arr, pBitStrm, pErrCode) ) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    return TRUE;
}


void MyTestPDU_Initialize(MyTestPDU* pVal)
{

    int i1 = 0;

    pVal->longitude = 0;
    pVal->latitude = 0;
    pVal->height = 0;
    pVal->subTypeArray.nCount = 0;
    for(i1=0;i1<15;i1++)
    {
        TypeNested_Initialize(&pVal->subTypeArray.arr[i1]);
    }
}


flag MyTestPDU_IsConstraintValid(MyTestPDU* pVal, int* pErrCode)
{
    int i1 = 0;

    if ( !(((pVal->longitude>=-180) && (pVal->longitude<=180))) ) {
        *pErrCode = ERR_MyTestPDU_longitude;
        return FALSE;
    }

    if ( !(((pVal->latitude>=-90) && (pVal->latitude<=90))) ) {
        *pErrCode = ERR_MyTestPDU_latitude;
        return FALSE;
    }

    if ( !(((pVal->height>=30000) && (pVal->height<=45000))) ) {
        *pErrCode = ERR_MyTestPDU_height;
        return FALSE;
    }

    if ( !(((pVal->subTypeArray.nCount>=1) && (pVal->subTypeArray.nCount<=15))) ) {
        *pErrCode = ERR_MyTestPDU_subTypeArray;
        return FALSE;
    }

    for(i1=0;i1<pVal->subTypeArray.nCount;i1++)
    {
        if ( !TypeNested_IsConstraintValid(&pVal->subTypeArray.arr[i1], pErrCode) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

flag MyTestPDU_Encode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    int i1 = 0;
    int i2 = 0;

    if (bCheckConstraints && !MyTestPDU_IsConstraintValid(pVal, pErrCode))
        return FALSE;

    /*Encode longitude (REAL)*/
    BitStream_EncodeReal(pBitStrm, pVal->longitude);

    /*Encode latitude (REAL)*/
    BitStream_EncodeReal(pBitStrm, pVal->latitude);

    /*Encode height (REAL)*/
    BitStream_EncodeReal(pBitStrm, pVal->height);

    /*Encode subTypeArray (SEQUENCE OF)*/
    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->subTypeArray.nCount, 1, 15);
    for(i1=0;i1<pVal->subTypeArray.nCount;i1++)
    {
        /*Encode childlen : (TypeNested)*/
        TypeNested_Encode(&pVal->subTypeArray.arr[i1], pBitStrm, pErrCode, FALSE);
    }

    return TRUE;
}

flag MyTestPDU_Decode(MyTestPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    asn1SccSint nCount = 0;
    int i1 = 0;
    int i2 = 0;
    asn1SccSint enumIndex = 0;

        /*Decode longitude (REAL)*/
    if (!BitStream_DecodeReal(pBitStrm, &pVal->longitude)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode latitude (REAL)*/
    if (!BitStream_DecodeReal(pBitStrm, &pVal->latitude)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode height (REAL)*/
    if (!BitStream_DecodeReal(pBitStrm, &pVal->height)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    /*Decode subTypeArray (SEQUENCE OF)*/
    if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 15)) {
        *pErrCode = ERR_INSUFFICIENT_DATA;
        return FALSE;
    }
    pVal->subTypeArray.nCount = (long)nCount;
    for(i1=0;i1<pVal->subTypeArray.nCount;i1++)
    {
        /*Decode childlen : (TypeNested)*/
        if ( !TypeNested_Decode(&pVal->subTypeArray.arr[i1], pBitStrm, pErrCode) ) {
            *pErrCode = ERR_INSUFFICIENT_DATA;
            return FALSE;
        }
    }
    return TRUE;
}


MyTestPDU testPDU = {
    .longitude = 3.14,
    .latitude = 2.718,
    .height = 32768,
    .subTypeArray = {
        2,
        {
            {
                .intVal = 3,
                .intArray = {
                    4,
                    {
                        2,
                        2,
                        3,
                        0
                    }
                },
                .boolArray = {
                    3,
                    {
                        TRUE,
                        FALSE,
                        TRUE
                    }
                },
                .enumValue = red,
                .label = {
                    2,
                    {
                        0x5F,
                        0x60
                    }
                },
                .bAlpha = TRUE,
                .bBeta = FALSE,
                .sString = {
                    2,
                    {
                        0x12,
                        0xBF
                    }
                },
                .arr = {
                    5,
                    {
                        1,
                        2,
                        3,
                        4,
                        0
                    }
                }
            },
            {
                .intVal = 3,
                .intArray = {
                    4,
                    {
                        2,
                        2,
                        3,
                        0
                    }
                },
                .boolArray = {
                    3,
                    {
                        TRUE,
                        FALSE,
                        TRUE
                    }
                },
                .enumValue = red,
                .label = {
                    2,
                    {
                        0x5F,
                        0x60
                    }
                },
                .bAlpha = TRUE,
                .bBeta = FALSE,
                .sString = {
                    2,
                    {
                        0x12,
                        0xBF
                    }
                },
                .arr = {
                    5,
                    {
                        1,
                        2,
                        3,
                        4,
                        0
                    }
                }
            }
        }
    }
};
